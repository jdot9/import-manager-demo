"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PrivateAppUserTokenManager = void 0;
const moment_1 = __importDefault(require("moment"));
const personalAccessKey_1 = require("@hubspot/local-dev-lib/personalAccessKey");
const index_1 = require("@hubspot/local-dev-lib/errors/index");
const privateAppUserToken_1 = require("../api/privateAppUserToken");
const constants_1 = require("./constants");
const messages_1 = require("./messages");
function getTokenExpirationDate() {
    return moment_1.default.utc().add(constants_1.TOKEN_TIME_TO_LIVE, 'minutes').toISOString();
}
function getExpDateWithThreashold(expiresAt) {
    /*
     * Subtracting the threshold from the expiration date to ensure
     * that the token is still valid when it's used. If we waint until
     * the expiration date, we could fire a request with an expired token.
     */
    return moment_1.default.utc(expiresAt).subtract(constants_1.TOKEN_REFRESH_THRESHOLD, 'minutes');
}
class PrivateAppUserTokenManager {
    accountId;
    tokenMap;
    enabled;
    logger;
    constructor(accountId, logger) {
        this.accountId = accountId;
        this.tokenMap = new Map();
        this.enabled = false;
        this.logger = logger;
    }
    async init() {
        const scopeGroups = new Set(await (0, personalAccessKey_1.scopesOnAccessToken)(this.accountId));
        if (scopeGroups.has(constants_1.USER_TOKEN_READ) && scopeGroups.has(constants_1.USER_TOKEN_WRITE)) {
            this.logger.info((0, messages_1.generateTokensEnableMessage)(this.accountId));
            this.enabled = true;
            return;
        }
        this.logger.info((0, messages_1.generateMissingScopesMessage)(this.accountId));
        this.logger.debug((0, messages_1.generateMissingScopesMoreContextMessage)(this.accountId));
    }
    isEnabled() {
        return this.enabled;
    }
    cleanup() {
        this.tokenMap.clear();
    }
    async getPrivateAppUserToken(appId, { scopeGroups = [], privateAppToken } = {}) {
        if (!this.isEnabled()) {
            this.logger.debug((0, messages_1.generateTokensNotEnabledMessage)(this.accountId, appId));
            return;
        }
        try {
            const tokenInCache = this.tokenMap.get(appId);
            // we have a token in cache and it's valid
            if (tokenInCache && this.validateToken(tokenInCache.token, scopeGroups)) {
                this.logger.debug((0, messages_1.generateCahedTokeMessage)(appId));
                return tokenInCache.token;
            }
            let token = await this.getExistingToken(appId);
            // token exists but it's not valid. Refresh it
            if (token && !this.validateToken(token, scopeGroups)) {
                token = await this.updateToken({
                    appId,
                    scopeGroups,
                    privateAppToken,
                    userTokenKey: token.userTokenKey,
                });
            }
            // token doesn't exist. Create a new one.
            else if (token === null) {
                token = await this.createNewToken(appId, scopeGroups, privateAppToken);
            }
            this.cacheToken(appId, token, scopeGroups);
            return token;
        }
        catch (err) {
            let messageDetail = 'Unknown error';
            if (err instanceof Error) {
                messageDetail = err.message;
            }
            throw new Error((0, messages_1.generateTokenOpErrorMessage)({
                operation: 'get',
                appId,
                accountId: this.accountId,
                messageDetail,
            }), { cause: err });
        }
    }
    cacheToken(appId, token, requestedScopeGroups) {
        if (!token) {
            throw new Error((0, messages_1.generateTokenOpErrorMessage)({
                appId,
                accountId: this.accountId,
                operation: 'refresh',
            }));
        }
        const cachedValue = {
            token,
            requestedScopeGroups,
        };
        this.tokenMap.set(appId, cachedValue);
        this.logger.debug((0, messages_1.generateTokenCachedMessage)(appId, token.expiresAt));
    }
    validateToken(token, scopeGroups) {
        if (!token) {
            return false;
        }
        const isTokenActive = moment_1.default
            .utc(moment_1.default.utc())
            .isBefore(getExpDateWithThreashold(token.expiresAt));
        const hasAllScopes = Array.isArray(scopeGroups) &&
            scopeGroups.every((scopeGroup) => token.scopeGroups.includes(scopeGroup));
        return isTokenActive && hasAllScopes;
    }
    async createNewToken(appId, scopeGroups, privateAppToken) {
        this.logger.debug((0, messages_1.generateCreateTokenMessage)(appId));
        const response = await (0, privateAppUserToken_1.createPrivateAppUserToken)({
            appId,
            scopeGroups,
            privateAppToken,
            accountId: this.accountId,
            expiresAt: getTokenExpirationDate(),
        });
        if (response.status === 200) {
            return response.data;
        }
        throw new Error((0, messages_1.generateTokenOpErrorMessage)({
            appId,
            operation: 'create',
            accountId: this.accountId,
        }));
    }
    async updateToken({ appId, userTokenKey, scopeGroups, privateAppToken, }) {
        this.logger.debug((0, messages_1.generateTokenRefreshMessage)(appId));
        const response = await (0, privateAppUserToken_1.updatePrivateAppUserToken)({
            appId,
            userTokenKey,
            scopeGroups,
            privateAppToken,
            accountId: this.accountId,
            expiresAt: getTokenExpirationDate(),
        });
        if (response.status === 200) {
            return response.data;
        }
        throw new Error((0, messages_1.generateTokenOpErrorMessage)({
            appId,
            accountId: this.accountId,
            operation: 'refresh',
        }));
    }
    async getExistingToken(appId) {
        try {
            const response = await (0, privateAppUserToken_1.fetchPrivateAppUserToken)({
                accountId: this.accountId,
                appId,
            });
            if (response.status === 200) {
                return response.data;
            }
            return null;
        }
        catch (err) {
            if ((0, index_1.isHubSpotHttpError)(err) && err?.status === 404) {
                return null;
            }
            throw err;
        }
    }
    static doesUserTokenContainAppTokenScopes(privateAppUserToken) {
        const privateAppToken = privateAppUserToken.privateAppTokenInfo;
        // if the private app token is not present, we can't compare the scopes
        if (!privateAppToken)
            return false;
        const privateAppTokenScopes = privateAppToken.scopeGroups ?? [];
        const privateAppUserTokenScopes = privateAppUserToken.scopeGroups ?? [];
        const areBothEmpty = privateAppUserTokenScopes.length === 0 &&
            privateAppTokenScopes.length === 0;
        return (areBothEmpty ||
            privateAppTokenScopes.every((scope) => privateAppUserTokenScopes.includes(scope)));
    }
}
exports.PrivateAppUserTokenManager = PrivateAppUserTokenManager;
