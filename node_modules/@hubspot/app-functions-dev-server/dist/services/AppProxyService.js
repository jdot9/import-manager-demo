"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AppProxyService = exports.extractErrorData = exports.mapToLocalUrl = void 0;
const express_1 = __importDefault(require("express"));
const cors_1 = __importDefault(require("cors"));
const axios_1 = __importStar(require("axios"));
const uuid_1 = require("uuid");
const constants_1 = require("../constants");
const signing_1 = require("../signing");
const mapToLocalUrl = (localDevUrlMapping, requestUri, allowedUrls, logger) => {
    const url = new URL(requestUri);
    if (allowedUrls && !allowedUrls.includes(url.origin)) {
        logger.warn(`'${url.origin}' is not in the 'allowedUrls' list in the application configuration file. Uploading the project in it's current state may result in request failures.`);
    }
    const localMapping = localDevUrlMapping[url.origin] || localDevUrlMapping[`${url.origin}/`];
    if (!localMapping) {
        return requestUri;
    }
    const parsedLocalMapping = new URL(localMapping);
    url.host = parsedLocalMapping.host;
    url.protocol = parsedLocalMapping.protocol;
    // The local mapping pathname is just slash, there is no need to merge
    if (parsedLocalMapping.pathname !== '/') {
        // If the local pathname ends with '/', remove it to avoid '//' in the path
        const localPathname = parsedLocalMapping.pathname.endsWith('/')
            ? parsedLocalMapping.pathname.slice(0, 1)
            : parsedLocalMapping.pathname;
        url.pathname = `${localPathname}${url.pathname}`;
    }
    const result = url.toString();
    // If the result ends with a '/' and the user didn't add it, remove it
    if (result.endsWith('/') && !localMapping.endsWith('/')) {
        return result.slice(0, -1);
    }
    return result;
};
exports.mapToLocalUrl = mapToLocalUrl;
const extractErrorData = (e) => {
    // If the error is not an AxiosError, it was an error with the local proxy
    if (!(0, axios_1.isAxiosError)(e)) {
        return constants_1.defaultServerError;
    }
    // Check if we have a mapping, otherwise fallback to the the default error
    let errorData = constants_1.axiosErrorMappings[e.code || ''] || constants_1.defaultServerError;
    if (e.response) {
        const { status, data } = e.response;
        errorData = { ...errorData, status, data };
    }
    return errorData;
};
exports.extractErrorData = extractErrorData;
const AppProxyService = ({ localDevUrlMapping, logger, accountId, allowedUrls, }) => {
    const app = (0, express_1.default)();
    app.use((0, cors_1.default)());
    app.use(express_1.default.json());
    app.post('/proxy', async (req, res) => {
        const correlationId = (0, uuid_1.v4)();
        const { requestUri, method, requestTimeoutMillis, requestBody, requestHeaders, } = 
        /* eslint-disable-next-line no-unsafe-optional-chaining */
        req?.body;
        try {
            logger.info(`Request to ${requestUri} started, method=${method}, correlationId=${correlationId}`);
            const url = (0, exports.mapToLocalUrl)(localDevUrlMapping, requestUri, allowedUrls, logger);
            logger.info(url === requestUri
                ? `No local mapping found, using ${requestUri}, correlationId=${correlationId}`
                : `Mapping ${requestUri} -> ${url}, correlationId=${correlationId}`);
            const headerKeys = Object.keys(requestHeaders || {});
            const tooManyHeaders = headerKeys.length > 1;
            /**
             * Mirroring what the backend is doing
             * https://git.hubteam.com/HubSpot/CRMExtensibility/blob/082c4468415dfa8492766e8eec59c072aed9a652/CRMExtensibilityExecutionService/src/main/java/com/hubspot/crm/extensibility/service/util/proxy/ProxyError.java#L23
             */
            if (tooManyHeaders) {
                const status = 400;
                const message = "Only 'Authorization' header is allowed";
                logger.warn(message);
                res.status(status).send({
                    category: 'VALIDATION_ERROR',
                    status: 'error',
                    message,
                    context: {
                        correlationId: [correlationId],
                        httpMethod: [method],
                        portalId: [`${accountId}`],
                        requestUri: [requestUri],
                    },
                });
                return;
            }
            const nonAuthHeader = headerKeys.some((header) => 'authorization' !== header.toLowerCase());
            /**
             * Mirroring what the backend is doing
             * https://git.hubteam.com/HubSpot/CRMExtensibility/blob/082c4468415dfa8492766e8eec59c072aed9a652/CRMExtensibilityExecutionService/src/main/java/com/hubspot/crm/extensibility/service/util/proxy/ProxyError.java#L15
             */
            if (nonAuthHeader) {
                const status = 400;
                const message = "Invalid Request Headers provided. Only 'Authorization' header is allowed from hubspot.fetch()";
                logger.warn(message);
                res.status(status).send({
                    category: 'VALIDATION_ERROR',
                    status: 'error',
                    message,
                    context: {
                        correlationId: [correlationId],
                        httpMethod: [method],
                        portalId: [`${accountId}`],
                        requestUri: [requestUri],
                    },
                });
                return;
            }
            const data = requestBody === undefined || requestBody === null
                ? ''
                : JSON.stringify(requestBody);
            const { status, data: responseBody } = await axios_1.default.request({
                url,
                method,
                timeout: requestTimeoutMillis,
                data,
                headers: {
                    ...requestHeaders,
                    ...(0, signing_1.getSignatureHeaders)({ method, url, requestBody }),
                    'content-type': 'application/json',
                },
                maxRedirects: 0,
            });
            res.status(status).send({
                status: 'success',
                responseBody,
                context: {
                    correlationId: [correlationId],
                    httpMethod: [method],
                    appServerStatusCode: [`${status}`],
                    portalId: [`${accountId}`],
                    requestUri: [requestUri],
                },
            });
        }
        catch (e) {
            const { status, message, category, data: responseBody, } = (0, exports.extractErrorData)(e);
            // This is mirroring current backend proxy behavior
            if (status >= 300 && status <= 599) {
                const { status: proxyStatus, message: proxyMessage, category: proxyCategory, } = constants_1.localProxyErrorMappings.BAD_GATEWAY;
                res.status(proxyStatus).send({
                    status: 'error',
                    context: {
                        portalId: [`${accountId}`],
                        httpMethod: [method],
                        requestUri: [requestUri],
                        correlationId: [correlationId],
                        appServerStatusCode: [`${status}`],
                    },
                    message: proxyMessage,
                    responseBody,
                    errors: [
                        {
                            message: `Unacceptable HTTP status ${status} calling ${requestUri}`,
                        },
                    ],
                    category: proxyCategory,
                });
                return;
            }
            res.status(status).send({
                status: 'error',
                message,
                category,
                context: {
                    correlationId: [correlationId],
                    httpMethod: [method],
                    appServerStatusCode: [`${status}`],
                    portalId: [`${accountId}`],
                    requestUri: [requestUri],
                },
                responseBody,
                errors: responseBody ? [responseBody] : undefined,
            });
        }
        finally {
            logger.info(`Request completed, correlationId=${correlationId}`);
        }
    });
    return app;
};
exports.AppProxyService = AppProxyService;
