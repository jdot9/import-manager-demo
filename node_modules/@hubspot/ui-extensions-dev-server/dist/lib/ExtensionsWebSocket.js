import { WebSocket, WebSocketServer } from 'ws';
export const ALLOWED_ORIGIN_PATTERNS = [
    /^https?:\/\/localhost(:\d+)?$/,
    /^https?:\/\/([\w-]+\.)?hubspot(qa)?\.com(:\d+)?$/,
];
export function isAllowedOrigin(origin) {
    if (!origin)
        return false;
    return ALLOWED_ORIGIN_PATTERNS.some((pattern) => pattern.test(origin));
}
export class ExtensionsWebSocket {
    wss;
    logger;
    keepAliveIntervalId;
    clientAliveness = new WeakMap();
    constructor(httpServer, devServerState) {
        this.logger = devServerState.logger;
        this.wss = new WebSocketServer({ noServer: true });
        this.setupUpgradeHandler(httpServer);
        this.setupErrorHandlers();
        this.startKeepAlive();
    }
    setupUpgradeHandler(httpServer) {
        httpServer.on('upgrade', (request, socket, head) => {
            if (!isAllowedOrigin(request.headers.origin)) {
                this.logger.debug(`Rejected WebSocket: ${request.headers.origin}`);
                socket.destroy();
                return;
            }
            this.wss.handleUpgrade(request, socket, head, (ws) => {
                this.setupClientHandlers(ws);
                this.wss.emit('connection', ws, request);
            });
        });
    }
    setupErrorHandlers() {
        this.wss.on('error', (error) => {
            this.logger.error(`WebSocket server error: ${error}`);
        });
    }
    setupClientHandlers(ws) {
        ws.on('error', (error) => {
            this.logger.debug(`Client error: ${error.message}`);
        });
        ws.on('close', (code, reason) => {
            this.logger.debug(`Client disconnected: ${code} ${reason}`);
        });
        ws.on('pong', () => {
            this.clientAliveness.set(ws, true);
        });
    }
    startKeepAlive() {
        this.keepAliveIntervalId = setInterval(() => {
            this.wss.clients.forEach((client) => {
                if (this.clientAliveness.get(client) === false) {
                    return client.terminate();
                }
                this.clientAliveness.set(client, false);
                client.ping();
            });
        }, 30000);
    }
    broadcast(message) {
        if (this.wss.clients.size === 0) {
            this.logger.debug('No clients connected, message not sent');
            return;
        }
        const data = JSON.stringify(message);
        let successCount = 0;
        let failCount = 0;
        this.wss.clients.forEach((client) => {
            if (client.readyState === WebSocket.OPEN) {
                try {
                    client.send(data);
                    successCount++;
                }
                catch (error) {
                    failCount++;
                    this.logger.debug(`Failed to send to client: ${error}`);
                }
            }
        });
        if (failCount > 0) {
            this.logger.warn(`Sent to ${successCount} clients, ${failCount} failed`);
        }
    }
    onConnection(handler) {
        this.wss.on('connection', handler);
    }
    get clientCount() {
        return this.wss.clients.size;
    }
    async close() {
        if (this.keepAliveIntervalId) {
            clearInterval(this.keepAliveIntervalId);
        }
        this.wss.clients.forEach((client) => {
            this.logger.debug('Terminating WebSocket client connection');
            client.terminate();
        });
        return new Promise((resolve, reject) => {
            this.wss.close((err) => {
                if (err)
                    reject(err);
                else
                    resolve();
            });
        });
    }
}
