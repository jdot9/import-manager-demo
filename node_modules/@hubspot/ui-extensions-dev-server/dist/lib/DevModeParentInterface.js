import { PLATFORM_VERSION } from "./constants.js";
import { startDevMode } from "./dev.js";
import { loadLocalConfig } from "./config.js";
import { throwUnhandledPlatformVersionError } from "./utils.js";
import { DevServerState } from "./DevServerState.js";
import inquirer from 'inquirer';
import { EXPRESS_DEFAULT_PORT, EXPRESS_SERVER_ID } from "./constants.js";
const defaultLogger = {
    info: (...args) => {
        console.log(...args);
    },
    debug: (...args) => {
        console.log(...args);
    },
    warn: (...args) => {
        console.error(...args);
    },
    error: (...args) => {
        console.error(...args);
    },
};
export class DevModeParentInterface {
    configs;
    devServerState;
    onUploadRequired;
    logger = defaultLogger;
    urls;
    isConfigured;
    isRunning;
    shutdown;
    _getPlatformVersion(projectConfig) {
        const { platformVersion } = projectConfig ?? {};
        if (!platformVersion) {
            return PLATFORM_VERSION.V20231;
        }
        switch (platformVersion) {
            case PLATFORM_VERSION.V20231:
                return PLATFORM_VERSION.V20231;
            case PLATFORM_VERSION.V20232:
                return PLATFORM_VERSION.V20232;
            case PLATFORM_VERSION.V20251:
                return PLATFORM_VERSION.V20251;
            case PLATFORM_VERSION.V20252:
            case PLATFORM_VERSION.UNSTABLE:
                return PLATFORM_VERSION.V20252;
            default:
                return throwUnhandledPlatformVersionError(platformVersion);
        }
    }
    _reset() {
        this.configs = undefined;
        this.devServerState = undefined;
        this.onUploadRequired = undefined;
        this.shutdown = undefined;
        this.logger = defaultLogger;
        this.urls = undefined;
        this.isConfigured = false;
        this.isRunning = false;
    }
    async parentSetup({ onUploadRequired, logger, urls, setActiveApp, choices = [], }) {
        if (this.isConfigured) {
            logger.debug('Dev server has already been configured, skipping');
            return;
        }
        this.logger = logger;
        this.onUploadRequired = onUploadRequired;
        this.urls = urls;
        if (choices.length === 0) {
            throw new Error('No extensions to run');
        }
        else if (choices.length === 1) {
            this.configs = [choices[0].value];
        }
        else {
            const promptModule = inquirer.createPromptModule();
            const answers = await promptModule({
                type: 'checkbox',
                name: 'extensions',
                message: 'Which extension(s) would you like to run?',
                validate: (selectedChoices) => {
                    if (!selectedChoices || selectedChoices.length === 0) {
                        return 'Select at least one extension to run';
                    }
                    const configs = selectedChoices
                        .map((choice) => choice.value)
                        .filter((value) => {
                        return (typeof value === 'object' && value !== null && 'data' in value);
                    });
                    if (configs.length !== selectedChoices.length) {
                        return 'Invalid extension configuration';
                    }
                    const appNames = new Set(configs.map((config) => config.data.appName));
                    if (appNames.size > 1) {
                        return 'Running multiple extensions is only supported for a single application';
                    }
                    return true;
                },
                choices,
            });
            this.configs = answers.extensions;
        }
        this.isConfigured = true;
        if (typeof setActiveApp === 'function') {
            await setActiveApp(this.configs?.[0]?.appConfig?.uid);
        }
    }
    async start({ requestPorts, accountId, projectConfig, }) {
        this.logger.debug('Start function was invoked', {
            accountId,
            projectConfig,
        });
        if (this.isRunning) {
            this.logger.debug('Dev server is already running, not starting again');
            return;
        }
        let expressPort = EXPRESS_DEFAULT_PORT;
        if (requestPorts) {
            try {
                const portData = await requestPorts([
                    { instanceId: EXPRESS_SERVER_ID, port: EXPRESS_DEFAULT_PORT },
                ]);
                expressPort = portData[EXPRESS_SERVER_ID];
            }
            catch (e) {
                if (e?.status === 409) {
                    throw new Error('Another instance is already running. To proceed, please stop the existing server and try again.');
                }
                this.logger.debug('Call to port manager failed, using default ports');
            }
        }
        const { proxy: localDevUrlMapping } = loadLocalConfig(this.configs?.[0]?.path || '', this.logger) || {};
        try {
            this.devServerState = new DevServerState({
                localDevUrlMapping,
                extensionConfigs: this.configs,
                accountId,
                platformVersion: this._getPlatformVersion(projectConfig),
                expressPort,
                logger: this.logger,
                urls: this.urls,
                appConfig: this.configs?.[0]?.appConfig,
            });
        }
        catch (e) {
            this.logger.debug('Error setting up DevServerState', e);
            throw e;
        }
        try {
            this.shutdown = await startDevMode(this.devServerState);
        }
        catch (e) {
            this.logger.debug('Error starting dev mode', e);
            throw e;
        }
        const { extensionsMetadata } = this.devServerState;
        extensionsMetadata.forEach((metadata) => {
            const { config: { data: { title, appName }, }, } = metadata;
            this.logger.info(`Running extension '${title}' from app '${appName}'`);
        });
        this.isRunning = true;
    }
    // The contract is for this to be async, with the __event param. Eslint doesn't like it.
    // eslint-disable-next-line require-await
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async fileChange(filePath, __event) {
        if (!this.devServerState || !this.devServerState.extensionsMetadata) {
            return;
        }
        const relevantConfigFileChanged = this.devServerState.extensionsMetadata.some((metadata) => metadata.config.extensionConfigPath === filePath);
        if (relevantConfigFileChanged && this.onUploadRequired) {
            this.onUploadRequired();
        }
    }
    async cleanup() {
        if (this.shutdown) {
            await this.shutdown();
        }
        // Since the DevModeInterface is a singleton, we need to wipe out the state when we shutdown
        this._reset();
    }
}
