import { describe, it, expect, vi, afterEach } from 'vitest';
vi.mock('vite');
import { buildSingleExtension, remoteBuild, extensionErrorBaseMessage, } from "../build.js";
import { build } from 'vite';
import { ROLLUP_OPTIONS } from "../constants.js";
describe('build', () => {
    afterEach(() => {
        vi.clearAllMocks();
    });
    describe('buildSingleExtension', () => {
        it('should build without the need to load config', async () => {
            await buildSingleExtension({
                file: 'SomeFile.jsx',
                outputDir: 'builds',
                emptyOutDir: false,
                minify: true,
                root: '/some/fake/dir',
            });
            expect(build).toHaveBeenCalledTimes(1);
        });
        it("should call vite's build function with the correct arguments", async () => {
            const expected = {
                file: 'SomeFile.jsx',
                outputDir: 'builds',
                emptyOutDir: false,
                minify: true,
                root: '/some/fake/dir',
            };
            const output = 'SomeFile.js';
            await buildSingleExtension(expected);
            expect(build).toHaveBeenCalledTimes(1);
            expect(build).toHaveBeenCalledWith(expect.objectContaining({
                root: expected.root,
                build: expect.objectContaining({
                    emptyOutDir: expected.emptyOutDir,
                    lib: expect.objectContaining({
                        entry: expected.file,
                        name: output,
                        formats: ['iife'],
                    }),
                    outDir: expected.outputDir,
                    minify: expected.minify,
                    rollupOptions: {
                        ...ROLLUP_OPTIONS,
                        plugins: expect.arrayContaining([
                            expect.objectContaining({
                                name: 'ui-extensions-manifest-generation-plugin',
                            }),
                            expect.objectContaining({
                                name: 'ui-extensions-friendly-logging-plugin',
                            }),
                            expect.objectContaining({
                                name: 'ui-extensions-code-blocking-plugin',
                            }),
                        ]),
                    },
                }),
            }));
        });
        it('should pass appConfig to manifestPlugin when provided', async () => {
            const mockAppConfig = {
                variables: {
                    name: 'Test Extension',
                    version: '1.0.0',
                },
            };
            await buildSingleExtension({
                file: 'SomeFile.jsx',
                outputDir: 'builds',
                emptyOutDir: false,
                minify: true,
                root: '/some/fake/dir',
                appConfig: mockAppConfig,
            });
            expect(build).toHaveBeenCalledTimes(1);
            expect(build).toHaveBeenCalledWith(expect.objectContaining({
                build: expect.objectContaining({
                    rollupOptions: expect.objectContaining({
                        plugins: expect.arrayContaining([
                            expect.objectContaining({
                                name: 'ui-extensions-manifest-generation-plugin',
                            }),
                        ]),
                    }),
                }),
            }));
        });
        it('should work without appConfig parameter', async () => {
            await buildSingleExtension({
                file: 'SomeFile.jsx',
                outputDir: 'builds',
                emptyOutDir: false,
                minify: true,
                root: '/some/fake/dir',
            });
            expect(build).toHaveBeenCalledTimes(1);
        });
    });
    describe('remoteBuild', () => {
        it('should throw an error for invalid file extensions', async () => {
            await expect(remoteBuild({ root: '/fake/file/path', entryPoint: 'file.xml' })).rejects.toThrow(`${extensionErrorBaseMessage} .xml`);
        });
        it('should call build with the correct arguments', async () => {
            const root = '/fake/file/path';
            const entry = 'file.jsx';
            const outDir = 'someOutDir';
            await remoteBuild({ root, entryPoint: entry, outputDir: outDir });
            expect(build).toHaveBeenCalledTimes(1);
            expect(build).toHaveBeenCalledWith(expect.objectContaining({
                build: expect.objectContaining({
                    emptyOutDir: true,
                    lib: expect.objectContaining({
                        entry,
                        name: 'file.js',
                    }),
                    outDir,
                    minify: true,
                }),
                root,
            }));
        });
        it('should pass appConfig parameter when provided', async () => {
            const mockAppConfig = {
                variables: {
                    name: 'Test Remote Extension',
                    version: '2.0.0',
                },
            };
            const root = '/fake/file/path';
            const entry = 'file.jsx';
            const outDir = 'someOutDir';
            await remoteBuild({
                root,
                entryPoint: entry,
                outputDir: outDir,
                appConfig: mockAppConfig,
            });
            expect(build).toHaveBeenCalledTimes(1);
            expect(build).toHaveBeenCalledWith(expect.objectContaining({
                build: expect.objectContaining({
                    emptyOutDir: true,
                    lib: expect.objectContaining({
                        entry,
                        name: 'file.js',
                    }),
                    outDir,
                    minify: true,
                }),
                root,
            }));
        });
        it('should work without appConfig parameter', async () => {
            const root = '/fake/file/path';
            const entry = 'file.jsx';
            await remoteBuild({ root, entryPoint: entry });
            expect(build).toHaveBeenCalledTimes(1);
        });
    });
});
