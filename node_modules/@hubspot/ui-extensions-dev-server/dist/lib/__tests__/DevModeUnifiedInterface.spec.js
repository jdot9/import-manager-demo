import { describe, it, expect, vi, beforeEach, afterEach, } from 'vitest';
import DevModeUnifiedInterface from "../DevModeUnifiedInterface.js";
import { DevModeParentInterface } from "../DevModeParentInterface.js";
import * as config from "../config.js";
import { cardConfig, cardConfigTwo, transformedUnifiedAppConfig, transformedUnifiedAppConfigTwoCards, transformedUnifiedCardOneConfig, transformedUnifiedCardTwoConfig, unifiedAppConfig, unifiedCardOneConfig, unifiedCardTwoConfig, settingsExtensionConfig, settingsExtensionTransformedData, appHomesConfig, appHomesTransformedData, } from "./fixtures/extensionConfig.js";
import inquirer from 'inquirer';
import { urls } from "./fixtures/urls.js";
vi.mock('../config.ts', async () => {
    const actual = await vi.importActual('../config.ts');
    return {
        ...actual,
        loadExtensionConfig: vi.fn(),
    };
});
vi.mock('inquirer', () => ({
    default: {
        createPromptModule: vi.fn(),
    },
}));
describe('DevModeUnifiedInterface', () => {
    describe('setup', () => {
        let parentSetupSpy;
        let mockPromptModule;
        let setActiveApp;
        let logger;
        const cardKey = `${unifiedAppConfig.uid}::${cardConfig.data.uid}`;
        const components = {
            application_name: unifiedAppConfig,
            card_one: unifiedCardOneConfig,
        };
        const expectedConfig = {
            ...transformedUnifiedCardOneConfig,
            appConfig: transformedUnifiedAppConfig,
        };
        const cardOneChoiceName = `${unifiedAppConfig.config.name}/${unifiedCardOneConfig.config.name}`;
        beforeEach(() => {
            DevModeUnifiedInterface._reset();
            logger = {
                info: vi.fn(),
                debug: vi.fn(),
                warn: vi.fn(),
                error: vi.fn(),
            };
            DevModeUnifiedInterface.logger = logger;
            mockPromptModule = vi.fn().mockResolvedValue({
                extensions: [expectedConfig],
            });
            vi.mocked(inquirer.createPromptModule).mockReturnValue(mockPromptModule);
            setActiveApp = vi.fn(() => {
                return Promise.resolve();
            });
            parentSetupSpy = vi.spyOn(DevModeParentInterface.prototype, 'parentSetup');
            vi.mocked(config.loadExtensionConfig).mockReturnValue({
                [cardKey]: cardConfig,
            });
        });
        afterEach(() => {
            vi.clearAllMocks();
        });
        it('should throw an error if no extensions are parsed from the provided arguments', async () => {
            const badComponents = {
                'not a valid application': {
                    config: {
                        name: 'I do not have an extensions object',
                    },
                    path: '/path/to/my/application',
                },
            };
            await expect(DevModeUnifiedInterface.setup({
                // @ts-expect-error - We're trying to trigger an error with bad data
                components: badComponents,
                logger,
                setActiveApp,
                urls,
            })).rejects.toThrowError('No extensions to run');
        });
        it('should directly set configs when there is only one choice', async () => {
            await DevModeUnifiedInterface.setup({
                components,
                logger,
                setActiveApp,
                urls,
            });
            expect(parentSetupSpy).toHaveBeenCalledWith({
                choices: [
                    {
                        name: cardOneChoiceName,
                        value: expectedConfig,
                    },
                ],
                components,
                logger,
                setActiveApp,
                urls,
            });
            expect(DevModeUnifiedInterface.configs).toStrictEqual([expectedConfig]);
        });
        it('should prompt the user when there is more than one choice', async () => {
            const twoCardComponents = {
                ...components,
                card_two: unifiedCardTwoConfig,
            };
            const cardOneKey = `${unifiedAppConfig.uid}::${unifiedCardOneConfig.uid}`;
            const cardTwoKey = `${unifiedAppConfig.uid}::${unifiedCardTwoConfig.uid}`;
            vi.mocked(config.loadExtensionConfig).mockReturnValue({
                [cardOneKey]: cardConfig,
                [cardTwoKey]: cardConfigTwo,
            });
            await DevModeUnifiedInterface.setup({
                components: twoCardComponents,
                logger,
                setActiveApp,
                urls,
            });
            expect(parentSetupSpy).toHaveBeenCalledWith({
                choices: [
                    {
                        name: cardOneChoiceName,
                        value: {
                            ...transformedUnifiedCardOneConfig,
                            appConfig: transformedUnifiedAppConfigTwoCards,
                        },
                    },
                    {
                        name: `${unifiedAppConfig.config.name}/${unifiedCardTwoConfig.config.name}`,
                        value: {
                            ...transformedUnifiedCardTwoConfig,
                            appConfig: transformedUnifiedAppConfigTwoCards,
                        },
                    },
                ],
                components: twoCardComponents,
                logger,
                setActiveApp,
                urls,
            });
            expect(mockPromptModule).toHaveBeenCalledTimes(1);
            expect(DevModeUnifiedInterface.configs).toStrictEqual([expectedConfig]);
        });
        it('should call setActiveApp with the correct arg', async () => {
            await DevModeUnifiedInterface.setup({
                components,
                logger,
                setActiveApp,
                urls,
            });
            expect(setActiveApp).toHaveBeenCalledTimes(1);
            expect(setActiveApp).toHaveBeenCalledWith(unifiedAppConfig.uid);
        });
        it('should not run setup if it has already been configured', async () => {
            DevModeUnifiedInterface.isConfigured = true;
            await DevModeUnifiedInterface.setup({
                components,
                logger,
                setActiveApp,
                urls,
            });
            expect(logger.debug).toHaveBeenCalledWith('Dev server has already been configured, skipping');
            expect(DevModeUnifiedInterface.configs).toBeUndefined();
        });
        it('should generate the correct configs for a settings card', async () => {
            const settingsComponents = {
                application_name: unifiedAppConfig,
                card_one: unifiedCardOneConfig,
                card_settings: settingsExtensionConfig,
            };
            mockPromptModule = vi.fn().mockResolvedValue({
                extensions: [expectedConfig, settingsExtensionTransformedData],
            });
            vi.mocked(inquirer.createPromptModule).mockReturnValue(mockPromptModule);
            await DevModeUnifiedInterface.setup({
                components: settingsComponents,
                logger,
                setActiveApp,
                urls,
            });
            expect(mockPromptModule).toHaveBeenCalledTimes(1);
            expect(DevModeUnifiedInterface.configs).toStrictEqual([
                expectedConfig,
                settingsExtensionTransformedData,
            ]);
            expect(DevModeUnifiedInterface.configs?.[1]).toHaveProperty('data.title', 'Settings');
        });
        it('should generate the correct configs for a pages extension', async () => {
            const pagesComponents = {
                application_name: unifiedAppConfig,
                card_one: unifiedCardOneConfig,
                app_homes: appHomesConfig,
            };
            mockPromptModule = vi.fn().mockResolvedValue({
                extensions: [expectedConfig, appHomesTransformedData],
            });
            vi.mocked(inquirer.createPromptModule).mockReturnValue(mockPromptModule);
            await DevModeUnifiedInterface.setup({
                components: pagesComponents,
                logger,
                setActiveApp,
                urls,
            });
            expect(mockPromptModule).toHaveBeenCalledTimes(1);
            expect(DevModeUnifiedInterface.configs).toStrictEqual([
                expectedConfig,
                appHomesTransformedData,
            ]);
            expect(DevModeUnifiedInterface.configs?.[1]).toHaveProperty('data.title', 'App Home');
        });
        it('should use profileData variables when provided', async () => {
            const profileData = {
                API_KEY: 'test-key-123',
                DEBUG_MODE: true,
                MAX_RETRIES: 5,
            };
            await DevModeUnifiedInterface.setup({
                components,
                profileData,
                logger,
                setActiveApp,
                urls,
            });
            const appConfig = DevModeUnifiedInterface.configs?.[0]
                ?.appConfig;
            expect(appConfig?.variables).toStrictEqual(profileData);
        });
        it('should use empty object for variables when no profileData provided', async () => {
            await DevModeUnifiedInterface.setup({
                components,
                logger,
                setActiveApp,
                urls,
            });
            const appConfig = DevModeUnifiedInterface.configs?.[0]
                ?.appConfig;
            expect(appConfig?.variables).toStrictEqual({});
        });
    });
});
