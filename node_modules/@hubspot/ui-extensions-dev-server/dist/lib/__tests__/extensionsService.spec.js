import { describe, it, expect, vi, beforeEach } from 'vitest';
import path from 'path';
vi.mock('../utils', () => ({
    loadManifest: vi.fn(() => {
        return {
            name: 'fake manifest file',
        };
    }),
}));
import { EXTENSIONS_MESSAGE_VERSION, PLATFORM_VERSION } from "../constants.js";
import extensionsService from "../extensionsService.js";
import { loadManifest } from "../utils.js";
import { DevServerState } from "../DevServerState.js";
import { createMockLogger, createDevServerConfig } from "./factories.js";
describe('extensionsService', () => {
    let devServerState;
    let logger;
    beforeEach(() => {
        logger = createMockLogger();
        devServerState = new DevServerState(createDevServerConfig(logger));
    });
    describe('add', () => {
        it('should add a GET endpoint to /extensions', () => {
            const server = {
                get: vi.fn(),
            };
            extensionsService.add(
            // TypeScript wants us to mock the entire Express Application object which is excessive
            server, devServerState, []);
            expect(server.get).toHaveBeenCalledTimes(1);
            expect(server.get).toHaveBeenCalledWith('/extensions', expect.any(Function));
        });
    });
    describe('generateExtensionsHandler', () => {
        it('should return a handler method', () => {
            const result = extensionsService.generateExtensionsHandler(devServerState);
            expect(result).toStrictEqual(expect.any(Function));
        });
        it('should return a handler that returns data about which extensions are running', () => {
            const capabilities = ['capability-1', 'capability-2'];
            const handler = extensionsService.generateExtensionsHandler(devServerState, capabilities);
            const jsonMethod = vi.fn();
            const response = {
                status: vi.fn(() => {
                    return {
                        json: jsonMethod,
                    };
                }),
            };
            // Don't want to mock full express types because they are huge, so type assert
            handler({}, response);
            const { outputDir, expressPort, portalId, extensionsMetadata } = devServerState;
            expect(loadManifest).toHaveBeenCalledTimes(1);
            expect(loadManifest).toHaveBeenCalledWith(outputDir, path.parse(extensionsMetadata[0].config.output).name);
            expect(response.status).toHaveBeenCalledTimes(1);
            expect(response.status).toBeCalledWith(200);
            expect(jsonMethod).toHaveBeenCalledTimes(1);
            expect(jsonMethod).toBeCalledWith({
                extensions: [
                    {
                        manifest: {
                            name: 'fake manifest file',
                        },
                        ...extensionsMetadata[0].baseMessage,
                    },
                ],
                portalId,
                version: EXTENSIONS_MESSAGE_VERSION,
                websocket: `ws://localhost:${expressPort}`,
                capabilities,
                platformVersion: PLATFORM_VERSION.V20231,
            });
        });
        it('should return a handler that includes platform version in response', () => {
            const capabilities = ['capability-1', 'capability-2'];
            const handler = extensionsService.generateExtensionsHandler(devServerState, capabilities);
            const jsonMethod = vi.fn();
            const response = {
                status: vi.fn(() => {
                    return {
                        json: jsonMethod,
                    };
                }),
            };
            handler({}, response);
            expect(jsonMethod).toHaveBeenCalledWith(expect.objectContaining({
                platformVersion: PLATFORM_VERSION.V20231,
            }));
        });
        it('should work when platform version is undefined', () => {
            const mockDevServerState = {
                extensionsMetadata: [
                    {
                        baseMessage: {
                            appName: 'Test App',
                            title: 'Test Extension',
                            callback: 'test.js',
                        },
                    },
                ],
                outputDir: '/test/output',
                webSocketPort: 2345,
                portalId: 12345,
                functionsConfig: {
                    platformVersion: undefined,
                },
            };
            const capabilities = ['capability-1', 'capability-2'];
            const handler = extensionsService.generateExtensionsHandler(
            // @ts-expect-error - we need to test the undefined state
            mockDevServerState, capabilities);
            const jsonMethod = vi.fn();
            const response = {
                status: vi.fn(() => {
                    return {
                        json: jsonMethod,
                    };
                }),
            };
            handler({}, response);
            const callArgs = jsonMethod.mock.calls[0][0];
            expect(callArgs).not.toHaveProperty('platformVersion');
        });
        it('should return a handler that sends error responses when something goes wrong', () => {
            const handler = extensionsService.generateExtensionsHandler(devServerState);
            const jsonMethod = vi.fn();
            const response = {
                status: vi.fn(() => {
                    return {
                        json: jsonMethod,
                    };
                }),
            };
            // @ts-expect-error TS thinks mockImplementationOnce doesn't exist
            loadManifest.mockImplementationOnce(() => {
                throw new Error('YOU SHALL NOT PASS');
            });
            // Don't want to mock full express types because they are huge, so type assert
            handler({}, response);
            expect(response.status).toHaveBeenCalledTimes(1);
            expect(response.status).toBeCalledWith(500);
            expect(jsonMethod).toHaveBeenCalledTimes(1);
            expect(jsonMethod).toBeCalledWith({
                message: 'Unable to determine which extensions are running',
            });
            expect(logger.error).toHaveBeenCalledTimes(1);
            expect(logger.error).toHaveBeenCalledWith(expect.stringContaining('Error in /extensions endpoint:'));
        });
    });
});
