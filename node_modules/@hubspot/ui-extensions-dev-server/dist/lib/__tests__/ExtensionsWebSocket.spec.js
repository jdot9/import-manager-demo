import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { ExtensionsWebSocket, isAllowedOrigin, } from "../ExtensionsWebSocket.js";
import { DevServerState } from "../DevServerState.js";
import { createMockLogger, createDevServerConfig } from "./factories.js";
const MOCK_INTERVAL_ID = 123;
let mockClients;
let mockWss;
let upgradeHandler = null;
vi.mock('ws', () => ({
    WebSocketServer: vi.fn(() => {
        mockClients = new Set();
        const listeners = {};
        let isClosed = false;
        mockWss = {
            clients: mockClients,
            on: vi.fn((event, handler) => {
                if (!listeners[event])
                    listeners[event] = [];
                listeners[event].push(handler);
            }),
            emit: vi.fn((event, ...args) => {
                listeners[event]?.forEach((handler) => handler(...args));
            }),
            handleUpgrade: vi.fn((request, socket, head, callback) => {
                const mockClient = createMockWebSocket();
                mockClients.add(mockClient);
                callback(mockClient);
            }),
            close: vi.fn((callback) => {
                if (isClosed) {
                    callback?.(new Error('The server is not running'));
                }
                else {
                    isClosed = true;
                    callback?.();
                }
            }),
        };
        return mockWss;
    }),
    WebSocket: { OPEN: 1, CLOSED: 3 },
}));
function createMockWebSocket() {
    const listeners = {};
    const mockWs = {
        readyState: 1,
        on: vi.fn((event, handler) => {
            if (!listeners[event])
                listeners[event] = [];
            listeners[event].push(handler);
        }),
        once: vi.fn(),
        emit: vi.fn((event, ...args) => {
            listeners[event]?.forEach((handler) => handler(...args));
        }),
        send: vi.fn(),
        close: vi.fn(() => {
            mockWs.readyState = 3;
            mockClients.delete(mockWs);
            listeners['close']?.forEach((handler) => handler());
        }),
        terminate: vi.fn(() => {
            mockWs.readyState = 3;
            mockClients.delete(mockWs);
        }),
        ping: vi.fn(),
    };
    return mockWs;
}
let mockHttpServer;
let devServerState;
let extensionsWebSocket;
function createMockHttpServer() {
    const listeners = {};
    return {
        on: vi.fn((event, handler) => {
            if (!listeners[event])
                listeners[event] = [];
            listeners[event].push(handler);
            if (event === 'upgrade') {
                upgradeHandler = handler;
            }
        }),
        emit: vi.fn((event, ...args) => {
            listeners[event]?.forEach((handler) => handler(...args));
        }),
        listen: vi.fn(),
        close: vi.fn(),
    };
}
function simulateClientConnection(origin = 'http://localhost') {
    if (!upgradeHandler)
        throw new Error('upgradeHandler not initialized');
    const mockRequest = { headers: { origin } };
    const mockSocket = { destroy: vi.fn() };
    upgradeHandler(mockRequest, mockSocket, Buffer.from([]));
    return {
        mockRequest,
        mockSocket,
        client: Array.from(mockClients)[mockClients.size - 1],
    };
}
describe('ExtensionsWebSocket', () => {
    describe('isAllowedOrigin', () => {
        it('should return false for undefined origin', () => {
            expect(isAllowedOrigin(undefined)).toBe(false);
        });
        it('should return true for localhost origins', () => {
            expect(isAllowedOrigin('http://localhost')).toBe(true);
            expect(isAllowedOrigin('https://localhost')).toBe(true);
            expect(isAllowedOrigin('https://localhost:8080')).toBe(true);
            expect(isAllowedOrigin('https://localhost:5173')).toBe(true);
        });
        it('should return true for hubspot.com origins', () => {
            expect(isAllowedOrigin('https://app.hubspot.com')).toBe(true);
            expect(isAllowedOrigin('http://hubspot.com')).toBe(true);
            expect(isAllowedOrigin('https://api.hubspot.com:443')).toBe(true);
        });
        it('should return true for hubspotqa.com origins', () => {
            expect(isAllowedOrigin('https://app.hubspotqa.com')).toBe(true);
            expect(isAllowedOrigin('http://hubspotqa.com')).toBe(true);
            expect(isAllowedOrigin('https://api.hubspotqa.com:443')).toBe(true);
        });
        it('should return false for non-allowed origins', () => {
            expect(isAllowedOrigin('https://evil.com')).toBe(false);
            expect(isAllowedOrigin('http://example.com')).toBe(false);
            expect(isAllowedOrigin('https://hubspot.com.evil.com')).toBe(false);
        });
    });
    describe('ExtensionsWebSocket class', () => {
        beforeEach(() => {
            const logger = createMockLogger();
            const config = createDevServerConfig(logger);
            devServerState = new DevServerState(config);
            mockHttpServer = createMockHttpServer();
            mockClients = new Set();
        });
        afterEach(() => {
            vi.useRealTimers();
            vi.clearAllMocks();
            mockClients.clear();
        });
        describe('constructor', () => {
            it('should create an ExtensionsWebSocket instance', () => {
                extensionsWebSocket = new ExtensionsWebSocket(mockHttpServer, devServerState);
                expect(extensionsWebSocket).toBeDefined();
            });
        });
        describe('setupUpgradeHandler', () => {
            it('should reject connections from non-allowed origins', () => {
                extensionsWebSocket = new ExtensionsWebSocket(mockHttpServer, devServerState);
                const mockSocket = {
                    destroy: vi.fn(),
                };
                const mockRequest = {
                    headers: {
                        origin: 'https://evil.com',
                    },
                };
                mockHttpServer.emit('upgrade', mockRequest, mockSocket, Buffer.from([]));
                expect(mockSocket.destroy).toHaveBeenCalled();
                expect(devServerState.logger.debug).toHaveBeenCalledWith('Rejected WebSocket: https://evil.com');
            });
            it('should accept connections from allowed origins', () => {
                extensionsWebSocket = new ExtensionsWebSocket(mockHttpServer, devServerState);
                simulateClientConnection('http://localhost');
                expect(extensionsWebSocket.clientCount).toBe(1);
            });
        });
        describe('broadcast', () => {
            it('should log when no clients are connected', () => {
                extensionsWebSocket = new ExtensionsWebSocket(mockHttpServer, devServerState);
                extensionsWebSocket.broadcast({ event: 'test' });
                expect(devServerState.logger.debug).toHaveBeenCalledWith('No clients connected, message not sent');
            });
            it('should send messages to all connected clients', () => {
                extensionsWebSocket = new ExtensionsWebSocket(mockHttpServer, devServerState);
                const { client: client1 } = simulateClientConnection();
                const { client: client2 } = simulateClientConnection();
                extensionsWebSocket.broadcast({ event: 'test', data: 'hello' });
                expect(client1.send).toHaveBeenCalledWith(JSON.stringify({ event: 'test', data: 'hello' }));
                expect(client2.send).toHaveBeenCalledWith(JSON.stringify({ event: 'test', data: 'hello' }));
            });
            it('should handle send failures gracefully', () => {
                extensionsWebSocket = new ExtensionsWebSocket(mockHttpServer, devServerState);
                const { client } = simulateClientConnection();
                vi.mocked(client.send).mockImplementation(() => {
                    throw new Error('Send failed');
                });
                extensionsWebSocket.broadcast({ event: 'test' });
                expect(devServerState.logger.warn).toHaveBeenCalledWith('Sent to 0 clients, 1 failed');
            });
        });
        describe('onConnection', () => {
            it('should register connection handler', () => {
                extensionsWebSocket = new ExtensionsWebSocket(mockHttpServer, devServerState);
                let connectionHandlerCalled = false;
                extensionsWebSocket.onConnection(() => {
                    connectionHandlerCalled = true;
                });
                simulateClientConnection();
                expect(connectionHandlerCalled).toBe(true);
            });
        });
        describe('clientCount', () => {
            it('should return 0 when no clients are connected', () => {
                extensionsWebSocket = new ExtensionsWebSocket(mockHttpServer, devServerState);
                expect(extensionsWebSocket.clientCount).toBe(0);
            });
            it('should return correct count of connected clients', () => {
                extensionsWebSocket = new ExtensionsWebSocket(mockHttpServer, devServerState);
                simulateClientConnection();
                simulateClientConnection();
                expect(extensionsWebSocket.clientCount).toBe(2);
            });
        });
        describe('keepAlive', () => {
            it('should terminate clients that do not respond to ping', () => {
                let keepAliveCallback;
                const setIntervalSpy = vi
                    .spyOn(global, 'setInterval')
                    .mockImplementation((fn) => {
                    keepAliveCallback = fn;
                    return MOCK_INTERVAL_ID;
                });
                extensionsWebSocket = new ExtensionsWebSocket(mockHttpServer, devServerState);
                const { client } = simulateClientConnection();
                // First keepAlive call: marks client as not alive and sends ping
                keepAliveCallback();
                // Second keepAlive call: should terminate since client didn't respond
                keepAliveCallback();
                expect(client.terminate).toHaveBeenCalled();
                setIntervalSpy.mockRestore();
            });
        });
        describe('client handlers', () => {
            it('should log client errors', () => {
                extensionsWebSocket = new ExtensionsWebSocket(mockHttpServer, devServerState);
                const { client } = simulateClientConnection();
                client.emit('error', new Error('Test error'));
                expect(devServerState.logger.debug).toHaveBeenCalledWith('Client error: Test error');
            });
            it('should log client disconnections', () => {
                extensionsWebSocket = new ExtensionsWebSocket(mockHttpServer, devServerState);
                const { client } = simulateClientConnection();
                client.close();
                const debugCalls = vi.mocked(devServerState.logger.debug).mock.calls;
                const hasDisconnectLog = debugCalls.some((call) => call[0].includes('Client disconnected'));
                expect(hasDisconnectLog).toBe(true);
            });
        });
        describe('close', () => {
            it('should terminate all clients before closing', async () => {
                extensionsWebSocket = new ExtensionsWebSocket(mockHttpServer, devServerState);
                const { client: client1 } = simulateClientConnection();
                const { client: client2 } = simulateClientConnection();
                expect(extensionsWebSocket.clientCount).toBe(2);
                await extensionsWebSocket.close();
                expect(client1.terminate).toHaveBeenCalled();
                expect(client2.terminate).toHaveBeenCalled();
                expect(extensionsWebSocket.clientCount).toBe(0);
            });
            it('should close the WebSocket server after clients disconnect', async () => {
                extensionsWebSocket = new ExtensionsWebSocket(mockHttpServer, devServerState);
                const { client } = simulateClientConnection();
                expect(extensionsWebSocket.clientCount).toBe(1);
                client.close();
                await extensionsWebSocket.close();
                expect(extensionsWebSocket.clientCount).toBe(0);
            });
            it('should stop keep-alive mechanism after close', async () => {
                extensionsWebSocket = new ExtensionsWebSocket(mockHttpServer, devServerState);
                const { client } = simulateClientConnection();
                const clearIntervalSpy = vi.spyOn(global, 'clearInterval');
                client.close();
                await extensionsWebSocket.close();
                expect(clearIntervalSpy).toHaveBeenCalled();
                clearIntervalSpy.mockRestore();
            });
            it('should reject when close is called multiple times', async () => {
                extensionsWebSocket = new ExtensionsWebSocket(mockHttpServer, devServerState);
                await extensionsWebSocket.close();
                await expect(extensionsWebSocket.close()).rejects.toThrow('The server is not running');
            });
            it('should not broadcast after close', async () => {
                extensionsWebSocket = new ExtensionsWebSocket(mockHttpServer, devServerState);
                const { client } = simulateClientConnection();
                client.close();
                await extensionsWebSocket.close();
                extensionsWebSocket.broadcast({ event: 'test' });
                expect(devServerState.logger.debug).toHaveBeenCalledWith('No clients connected, message not sent');
            });
        });
        describe('error handlers', () => {
            it('should log WebSocket server errors', () => {
                extensionsWebSocket = new ExtensionsWebSocket(mockHttpServer, devServerState);
                const testError = new Error('Server error');
                const errorHandler = vi.mocked(mockWss.on).mock.calls.find((call) => call[0] === 'error')?.[1];
                errorHandler?.(testError);
                expect(devServerState.logger.error).toHaveBeenCalledWith('WebSocket server error: Error: Server error');
            });
        });
    });
});
