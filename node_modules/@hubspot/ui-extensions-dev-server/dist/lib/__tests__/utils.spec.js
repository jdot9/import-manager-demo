import { describe, it, expect, vi, beforeAll, afterAll, beforeEach, afterEach, } from 'vitest';
import { OUTPUT_DIR } from "../constants.js";
import { getUrlSafeFileName, stripAnsiColorCodes, loadManifest, buildSourceId, isNodeModule, isExtensionFile, generateHash, } from "../utils.js";
import fs from 'fs';
import path from 'path';
describe('utils', () => {
    describe('getUrlSafeFileName', () => {
        it('should uri encode the filename', () => {
            const fileName = 'test File ?@#$%^&*()Name who would name a file like this!';
            const actual = getUrlSafeFileName(`${fileName}.tsx`);
            expect(actual).toEqual(`${encodeURIComponent(fileName)}.js`);
        });
    });
    describe('stripAnsiColorCodes', () => {
        it('should strip all color codes out of a string', () => {
            const withColorCodes = '\x1B[33mThis is a test\x1B[39m';
            const actual = stripAnsiColorCodes(withColorCodes);
            expect(actual).toEqual('This is a test');
        });
        it('should return null if the provided string is null', () => {
            const actual = stripAnsiColorCodes(undefined);
            expect(actual).toEqual(null);
        });
        it('should return null if the provided string is undefined', () => {
            const actual = stripAnsiColorCodes(undefined);
            expect(actual).toEqual(null);
        });
        it('should return null if the provided string is empty', () => {
            const actual = stripAnsiColorCodes('');
            expect(actual).toEqual(null);
        });
    });
    describe('loadManifest', () => {
        beforeEach(() => {
            vi.spyOn(fs, 'readFileSync').mockReturnValue(JSON.stringify({
                manifest: true,
            }));
        });
        afterEach(() => {
            vi.restoreAllMocks();
        });
        it('should return the manifest file when it is able to load it from disk', () => {
            const actual = loadManifest(OUTPUT_DIR, 'test-file-name');
            expect(fs.readFileSync).toHaveBeenCalledTimes(1);
            expect(actual).toStrictEqual({
                manifest: true,
            });
        });
        it('should return an empty object when it fails to load from disk', () => {
            vi.spyOn(fs, 'readFileSync').mockImplementationOnce(() => {
                throw new Error('OH NO!');
            });
            const actual = loadManifest(OUTPUT_DIR, 'test-file-name');
            expect(actual).toStrictEqual({});
        });
    });
    describe('buildSourceId', () => {
        it('should return null when there is no uid in app config', () => {
            expect(buildSourceId({}, { data: { uid: 'some-uid' } })).toBe(null);
        });
        it('should return null when there is no uid in extension config', () => {
            expect(buildSourceId({ uid: 'some-uid' }, { data: {} })).toBe(null);
        });
        it('should return a valid sourceId', () => {
            const appUID = 'app-uid';
            const extensionUID = 'extension-uid';
            expect(buildSourceId({ uid: appUID }, { data: { uid: extensionUID } })).toBe(`${appUID}::${extensionUID}`);
        });
    });
    describe('isNodeModule', () => {
        it('should return false if the path is undefined', () => {
            expect(isNodeModule(undefined)).toBe(false);
        });
        it('should return false if the path is not a node_modules', () => {
            expect(isNodeModule('foo.js')).toBe(false);
        });
        it('should return true if the path is a node_modules', () => {
            expect(isNodeModule('node_modules/foo.js')).toBe(true);
        });
    });
    describe('isExtensionFile', () => {
        /**
         * This function relies on the file system. Mocking doesn't allow us to fully test all scenarios.
         * In order to effectively test it, we need to create a temporary directory structure.
         * Being thorough here allows us to safely mock it elsewhere.
         */
        const tempDir = path.join(__dirname, 'temp');
        const extensionDir = path.join(tempDir, 'test/path/extension');
        const indexFile = path.join(extensionDir, 'index.js');
        const nestedFile = path.join(extensionDir, 'src/file.ts');
        const otherFile = path.join(tempDir, 'different/path/file.ts');
        const relativeOtherFile = path.join(tempDir, '../different/path/file.ts');
        beforeAll(() => {
            fs.mkdirSync(extensionDir, { recursive: true });
            fs.mkdirSync(path.dirname(nestedFile), { recursive: true });
            fs.mkdirSync(path.dirname(otherFile), { recursive: true });
            fs.mkdirSync(path.dirname(relativeOtherFile), { recursive: true });
            fs.writeFileSync(otherFile, '');
            fs.writeFileSync(nestedFile, '');
            fs.writeFileSync(indexFile, '');
            fs.writeFileSync(relativeOtherFile, '');
        });
        afterAll(() => {
            fs.rmSync(tempDir, { recursive: true, force: true });
            fs.rmSync(relativeOtherFile, { recursive: true, force: true });
        });
        it('should return false if filepath is undefined', () => {
            expect(isExtensionFile(undefined, extensionDir)).toBe(false);
        });
        it('should return true if file is within extension path', () => {
            expect(isExtensionFile(nestedFile, extensionDir)).toBe(true);
            expect(isExtensionFile(indexFile, extensionDir)).toBe(true);
        });
        it('should return false if file is outside extension path', () => {
            expect(isExtensionFile(otherFile, extensionDir)).toBe(false);
        });
        it('should handle relative paths correctly', () => {
            const originalCwd = process.cwd();
            process.chdir(tempDir);
            expect(isExtensionFile('./test/path/extension/src/file.ts', './test/path/extension')).toBe(true);
            expect(isExtensionFile('../different/path/file.ts', './test/path/extension')).toBe(false);
            process.chdir(originalCwd);
        });
        it('should return true if the extension path is nested within the provided path', () => {
            const originalCwd = process.cwd();
            process.chdir(tempDir);
            expect(isExtensionFile('../temp/test/path/extension/src/file.ts', './test/path/extension/')).toBe(true);
            process.chdir(originalCwd);
        });
    });
    describe('generateHash', () => {
        it('should generate consistent hashes for same inputs', () => {
            const hash1 = generateHash('test', ['a', 'b'], { foo: 'bar' });
            const hash2 = generateHash('test', ['a', 'b'], { foo: 'bar' });
            expect(hash1).toBe(hash2);
        });
        it('should handle different types of arguments', () => {
            expect(generateHash('test')).toBe('364492');
            expect(generateHash(123)).toBe('be32');
            expect(generateHash(['a', 'b'])).toBe('171f6');
            expect(generateHash({ foo: 'bar' })).toBe('4a4201ac');
            expect(generateHash(null)).toBe('33c587');
            expect(generateHash(undefined)).toBe('42201c7f');
        });
        it('should generate the correct hash for multiple arguments', () => {
            const hash1 = generateHash('arg1', ['foo', 'bar']);
            const hash2 = generateHash('test', ['a', 'c', 'd', 'e']);
            expect(hash1).toBe('1ec304f1');
            expect(hash2).toBe('607ad458');
        });
        it('should normalize arrays regardless of order', () => {
            const hash1 = generateHash(['a', 'b', 'c']);
            const hash2 = generateHash(['c', 'a', 'b']);
            expect(hash1).toBe(hash2);
        });
        it('should normalize objects regardless of key order', () => {
            const hash1 = generateHash({ a: 1, b: 2 });
            const hash2 = generateHash({ b: 2, a: 1 });
            expect(hash1).toBe(hash2);
        });
        it('should return an empty string and log an error if an error is thrown', () => {
            // Mock console.error to prevent it from logging to the console
            const consoleErrorSpy = vi
                .spyOn(console, 'error')
                .mockImplementation(() => { });
            // Create an argument that will cause an error.
            const circularReference = {};
            circularReference.self = circularReference;
            const hash = generateHash(circularReference);
            expect(hash).toBe('');
            expect(consoleErrorSpy).toHaveBeenCalledWith('Error generating hash: ', expect.any(TypeError));
            // Restore console.error
            consoleErrorSpy.mockRestore();
        });
    });
});
