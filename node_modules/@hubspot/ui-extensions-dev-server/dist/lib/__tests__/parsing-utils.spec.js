import { describe, it, expect, vi } from 'vitest';
import { traverseAbstractSyntaxTree } from "../ast.js";
import { getValueFromNode, isVariableImported, isIdentifierDefined, isFunctionInvoked, } from "../parsing-utils.js";
import { localParse } from "./test-utils/ast.js";
const emptyState = {
    functions: {},
    badImports: [],
    variableDeclarations: new Map(),
    dataDependencies: {
        importedHooks: {},
        dependencies: [],
    },
};
const extensionPath = '/mock/extension/path';
const mockLogger = {
    debug: vi.fn(),
    info: vi.fn(),
    warn: vi.fn(),
    error: vi.fn(),
};
describe('Parsing Utils', () => {
    describe('getValueFromNode', () => {
        it('should extract literal values correctly', () => {
            const stringProgram = localParse(`const foo = "hello world";`);
            const numberProgram = localParse(`const foo = 42;`);
            const booleanProgram = localParse(`const foo = true;`);
            const nullProgram = localParse(`const foo = null;`);
            // Extract the literal nodes from variable declarations
            const stringLiteral = stringProgram.body[0].declarations[0].init;
            const numberLiteral = numberProgram.body[0].declarations[0].init;
            const booleanLiteral = booleanProgram.body[0].declarations[0]
                .init;
            const nullLiteral = nullProgram.body[0].declarations[0].init;
            expect(getValueFromNode(stringLiteral, emptyState)).toEqual({
                status: 'SUCCESS',
                nodeValue: 'hello world',
            });
            expect(getValueFromNode(numberLiteral, emptyState)).toEqual({
                status: 'SUCCESS',
                nodeValue: 42,
            });
            expect(getValueFromNode(booleanLiteral, emptyState)).toEqual({
                status: 'SUCCESS',
                nodeValue: true,
            });
            expect(getValueFromNode(nullLiteral, emptyState)).toEqual({
                status: 'SUCCESS',
                nodeValue: null,
            });
        });
        it('should return identifier values correctly', () => {
            const undefinedProgram = localParse(`const foo = undefined;`);
            const nanProgram = localParse(`const foo = NaN;`);
            const infinityProgram = localParse(`const foo = Infinity;`);
            const identifierProgram = localParse(`const foo = 'myVar';`);
            // Extract the identifier nodes from variable declarations
            const undefinedIdentifier = undefinedProgram.body[0]
                .declarations[0].init;
            const nanIdentifier = nanProgram.body[0].declarations[0].init;
            const infinityIdentifier = infinityProgram.body[0]
                .declarations[0].init;
            const identifierNode = identifierProgram.body[0].declarations[0]
                .init;
            const identifierOutput = traverseAbstractSyntaxTree(identifierProgram, [], extensionPath, mockLogger);
            expect(getValueFromNode(undefinedIdentifier, emptyState)).toEqual({
                status: 'SUCCESS',
                nodeValue: undefined,
            });
            expect(getValueFromNode(nanIdentifier, emptyState)).toEqual({
                status: 'SUCCESS',
                nodeValue: NaN,
            });
            expect(getValueFromNode(infinityIdentifier, emptyState)).toEqual({
                status: 'SUCCESS',
                nodeValue: Infinity,
            });
            expect(getValueFromNode(identifierNode, identifierOutput)).toEqual({
                status: 'SUCCESS',
                nodeValue: 'myVar',
            });
        });
        it('should extract array expressions correctly', () => {
            const program = localParse(`const foo = [1, "hello", true, null];`);
            const arrayExpression = program.body[0].declarations[0].init;
            expect(getValueFromNode(arrayExpression, emptyState)).toEqual({
                status: 'SUCCESS',
                nodeValue: [1, 'hello', true, null],
            });
        });
        it('should handle nested arrays correctly', () => {
            const program = localParse(`const foo = [1, [2, 3], ["nested"]];`);
            const arrayExpression = program.body[0].declarations[0].init;
            expect(getValueFromNode(arrayExpression, emptyState)).toEqual({
                status: 'SUCCESS',
                nodeValue: [1, [2, 3], ['nested']],
            });
        });
        it('should handle arrays with null/undefined elements', () => {
            const program = localParse(`const foo = [1, null, 3, undefined];`);
            const arrayExpression = program.body[0].declarations[0].init;
            expect(getValueFromNode(arrayExpression, emptyState)).toEqual({
                status: 'SUCCESS',
                nodeValue: [1, null, 3, undefined],
            });
        });
        it('should handle arrays with spread operators', () => {
            const program = localParse(`const foo = [1, 2, 3]; const bar = [...foo, ...[4, 5], 6];`);
            const output = traverseAbstractSyntaxTree(program, [], extensionPath, mockLogger);
            const arrayExpression = program.body[1].declarations[0].init;
            expect(getValueFromNode(arrayExpression, output)).toEqual({
                status: 'SUCCESS',
                nodeValue: [1, 2, 3, 4, 5, 6],
            });
        });
        it('should fail gracefully for unsupported spread operators', () => {
            const program = localParse(`const foo = () => [1, 2, 3]; const bar = [...foo(), ...[4, 5], 6];`);
            const output = traverseAbstractSyntaxTree(program, [], extensionPath, mockLogger);
            const arrayExpression = program.body[1].declarations[0].init;
            const result = getValueFromNode(arrayExpression, output);
            expect(result.status).toBe('FAIL');
            expect(result.error).toBe('Array spread element failed: Unsupported SpreadElement type: CallExpression');
        });
        it('should extract simple object expressions correctly', () => {
            const program = localParse(`const foo = { name: "John", age: 30 };`);
            const objectExpression = program.body[0].declarations[0].init;
            expect(getValueFromNode(objectExpression, emptyState)).toEqual({
                status: 'SUCCESS',
                nodeValue: {
                    name: 'John',
                    age: 30,
                },
            });
        });
        it('should handle object expressions with identifier keys', () => {
            const program = localParse(`const foo = { name: "John", age: 30 };`);
            const objectExpression = program.body[0].declarations[0].init;
            expect(getValueFromNode(objectExpression, emptyState)).toEqual({
                status: 'SUCCESS',
                nodeValue: {
                    name: 'John',
                    age: 30,
                },
            });
        });
        it('should handle object expressions with literal keys', () => {
            const program = localParse(`const foo = { "full-name": "John Doe", "age": 30 };`);
            const objectExpression = program.body[0].declarations[0].init;
            expect(getValueFromNode(objectExpression, emptyState)).toEqual({
                status: 'SUCCESS',
                nodeValue: {
                    'full-name': 'John Doe',
                    age: 30,
                },
            });
        });
        it('should handle nested object expressions correctly', () => {
            const program = localParse(`const foo = { person: { name: "John", details: { age: 30 } } };`);
            const objectExpression = program.body[0].declarations[0].init;
            expect(getValueFromNode(objectExpression, emptyState)).toEqual({
                status: 'SUCCESS',
                nodeValue: {
                    person: {
                        name: 'John',
                        details: {
                            age: 30,
                        },
                    },
                },
            });
        });
        it('should handle complex nested structures', () => {
            const program = localParse(`const foo = { users: ["John", "Jane"], config: { enabled: true, count: 5 } };`);
            const objectExpression = program.body[0].declarations[0].init;
            expect(getValueFromNode(objectExpression, emptyState)).toEqual({
                status: 'SUCCESS',
                nodeValue: {
                    users: ['John', 'Jane'],
                    config: {
                        enabled: true,
                        count: 5,
                    },
                },
            });
        });
        it('should handle objects with mixed key types', () => {
            const program = localParse(`const foo = { name: "John", "age": 30, 42: "answer" };`);
            const objectExpression = program.body[0].declarations[0].init;
            expect(getValueFromNode(objectExpression, emptyState)).toEqual({
                status: 'SUCCESS',
                nodeValue: {
                    name: 'John',
                    age: 30,
                    '42': 'answer',
                },
            });
        });
        it('should handle objects with spread operators', () => {
            const program = localParse(`const subObject = { akey: 'astring', bkey: 'bstring' }; const bar = {...subObject, ckey: 'cstring', akey: 'anotherstring'}`);
            const output = traverseAbstractSyntaxTree(program, [], extensionPath, mockLogger);
            const objectExpression = program.body[1].declarations[0].init;
            expect(getValueFromNode(objectExpression, output)).toEqual({
                status: 'SUCCESS',
                nodeValue: {
                    akey: 'anotherstring',
                    bkey: 'bstring',
                    ckey: 'cstring',
                },
            });
        });
        it('should return error message for unsupported node types', () => {
            const program = localParse(`const foo = () => {};`);
            const functionExpression = program.body[0].declarations[0].init;
            const result = getValueFromNode(functionExpression, emptyState);
            expect(result).toEqual({
                status: 'FAIL',
                error: 'Unsupported node type: ArrowFunctionExpression',
            });
        });
        it('should handle empty arrays correctly', () => {
            const program = localParse(`const foo = [];`);
            const arrayExpression = program.body[0].declarations[0].init;
            expect(getValueFromNode(arrayExpression, emptyState)).toEqual({
                status: 'SUCCESS',
                nodeValue: [],
            });
        });
        it('should handle empty objects correctly', () => {
            const program = localParse(`const foo = {};`);
            const objectExpression = program.body[0].declarations[0].init;
            expect(getValueFromNode(objectExpression, emptyState)).toEqual({
                status: 'SUCCESS',
                nodeValue: {},
            });
        });
        it('should skip object properties with unsupported key types', () => {
            // Create a mock node to simulate an unsupported key type
            const mockObjectExpression = {
                type: 'ObjectExpression',
                properties: [
                    {
                        type: 'Property',
                        key: { type: 'MemberExpression' }, // Unsupported key type
                        value: { type: 'Literal', value: 'test' },
                        kind: 'init',
                        method: false,
                        shorthand: false,
                        computed: false,
                    },
                ],
            };
            expect(getValueFromNode(mockObjectExpression, emptyState)).toEqual({
                status: 'SUCCESS',
                nodeValue: {},
            });
        });
        it('should handle template literals with various interpolations', () => {
            const testCases = [
                {
                    code: `const name = 'John'; const result = \`Hello \${name}\`;`,
                    expected: 'Hello John',
                },
                {
                    code: `const first = 'John'; const last = 'Doe'; const result = \`\${first} \${last}\`;`,
                    expected: 'John Doe',
                },
                { code: `const result = \`Hello World\`;`, expected: 'Hello World' },
                {
                    code: `const name = 'John'; const result = \`\${name}\`;`,
                    expected: 'John',
                },
                { code: `const result = \`\`;`, expected: '' },
                {
                    code: `const age = 25; const result = \`Age: \${age}\`;`,
                    expected: 'Age: 25',
                },
                {
                    code: `const flag = true; const result = \`Status: \${flag}\`;`,
                    expected: 'Status: true',
                },
                {
                    code: `const val = null; const result = \`Value: \${val}\`;`,
                    expected: 'Value: null',
                },
                {
                    code: `const arr = ['a', 'b']; const result = \`List: \${arr}\`;`,
                    expected: 'List: a,b',
                },
                {
                    code: `const obj = {name: 'test'}; const result = \`Obj: \${obj}\`;`,
                    expected: 'Obj: [object Object]',
                },
            ];
            testCases.forEach(({ code, expected }) => {
                const program = localParse(code);
                const output = traverseAbstractSyntaxTree(program, [], extensionPath, mockLogger);
                const templateLiteral = program.body[program.body.length - 1]
                    .declarations[0].init;
                expect(getValueFromNode(templateLiteral, output)).toEqual({
                    status: 'SUCCESS',
                    nodeValue: expected,
                });
            });
        });
        it('should handle unary expressions correctly', () => {
            const testCases = [
                { code: `const num = 5; const result = -num;`, expected: -5 },
                { code: `const num = 5; const result = +num;`, expected: 5 },
                { code: `const flag = true; const result = !flag;`, expected: false },
                {
                    code: `const val = 'test'; const result = typeof val;`,
                    expected: 'string',
                },
            ];
            testCases.forEach(({ code, expected }) => {
                const program = localParse(code);
                const output = traverseAbstractSyntaxTree(program, [], extensionPath, mockLogger);
                const unaryExpression = program.body[program.body.length - 1]
                    .declarations[0].init;
                expect(getValueFromNode(unaryExpression, output)).toEqual({
                    status: 'SUCCESS',
                    nodeValue: expected,
                });
            });
        });
        it('should fail for unsupported unary operators', () => {
            const program = localParse(`const result = void 0;`);
            const output = traverseAbstractSyntaxTree(program, [], extensionPath, mockLogger);
            const unaryExpression = program.body[0].declarations[0].init;
            expect(getValueFromNode(unaryExpression, output)).toEqual({
                status: 'FAIL',
                error: 'Unsupported unary operator: void',
            });
        });
        it('should handle member expressions with variable resolution', () => {
            const program = localParse(`
          const config = { prefix: 'user', nested: { suffix: 'name' } };
          const simple = config.prefix;
          const nested = config.nested.suffix;
          const deep = config.nested;
        `);
            const output = traverseAbstractSyntaxTree(program, [], extensionPath, mockLogger);
            const simpleMember = program.body[1].declarations[0].init;
            const nestedMember = program.body[2].declarations[0].init;
            const deepMember = program.body[3].declarations[0].init;
            expect(getValueFromNode(simpleMember, output)).toEqual({
                status: 'SUCCESS',
                nodeValue: 'user',
            });
            expect(getValueFromNode(nestedMember, output)).toEqual({
                status: 'SUCCESS',
                nodeValue: 'name',
            });
            expect(getValueFromNode(deepMember, output)).toEqual({
                status: 'SUCCESS',
                nodeValue: {
                    suffix: 'name',
                },
            });
        });
        it('should resolve identifiers to declared variables or return unsupported message as fallback', () => {
            const program = localParse(`
          const prefix = 'user';
          const config = { type: 'contact' };
          const resolvedVar = prefix;
          const resolvedObj = config;
          const undeclaredVar = someUndefinedVariable;
        `);
            const output = traverseAbstractSyntaxTree(program, [], extensionPath, mockLogger);
            const resolved1 = program.body[2].declarations[0].init;
            const resolved2 = program.body[3].declarations[0].init;
            const undeclared = program.body[4].declarations[0].init;
            expect(getValueFromNode(resolved1, output)).toEqual({
                status: 'SUCCESS',
                nodeValue: 'user',
            });
            expect(getValueFromNode(resolved2, output)).toEqual({
                status: 'SUCCESS',
                nodeValue: {
                    type: 'contact',
                },
            });
            expect(getValueFromNode(undeclared, output)).toEqual({
                status: 'FAIL',
                error: 'Identifier someUndefinedVariable is not found',
            });
        });
    });
    describe('isVariableImported', () => {
        it('should return true for ImportSpecifier with matching variable name', () => {
            const program = localParse(`import { React } from 'react';`);
            const importSpecifier = program.body[0].specifiers[0];
            expect(isVariableImported(importSpecifier, 'React')).toBe(true);
            expect(isVariableImported(importSpecifier, 'Component')).toBe(false);
        });
        it('should return true for ImportDefaultSpecifier with matching variable name', () => {
            const program = localParse(`import React from 'react';`);
            const importDefaultSpecifier = program.body[0].specifiers[0];
            expect(isVariableImported(importDefaultSpecifier, 'React')).toBe(true);
            expect(isVariableImported(importDefaultSpecifier, 'Component')).toBe(false);
        });
        it('should return true for ImportNamespaceSpecifier with matching variable name', () => {
            const program = localParse(`import * as React from 'react';`);
            const importNamespaceSpecifier = program.body[0].specifiers[0];
            expect(isVariableImported(importNamespaceSpecifier, 'React')).toBe(true);
            expect(isVariableImported(importNamespaceSpecifier, 'Component')).toBe(false);
        });
        it('should return false for null or undefined node', () => {
            expect(isVariableImported(null, 'React')).toBe(false);
            expect(isVariableImported(undefined, 'React')).toBe(false);
        });
        it('should return false for non-import node types', () => {
            const program = localParse(`const foo = 'bar';`);
            const variableDeclarator = program.body[0].declarations[0];
            expect(isVariableImported(variableDeclarator, 'foo')).toBe(false);
        });
    });
    describe('isIdentifierDefined', () => {
        it('should return true for Identifier node with matching name and no restricting parent', () => {
            const program = localParse(`const foo = bar;`);
            const identifier = program.body[0].declarations[0].init;
            expect(isIdentifierDefined(identifier, null, 'bar')).toBe(true);
            expect(isIdentifierDefined(identifier, null, 'baz')).toBe(false);
        });
        it('should return false when parent is MemberExpression', () => {
            const program = localParse(`const foo = obj.bar;`);
            const memberExpression = program.body[0].declarations[0].init;
            const identifier = memberExpression.property;
            expect(isIdentifierDefined(identifier, memberExpression, 'bar')).toBe(false);
        });
        it('should return false when parent is CallExpression', () => {
            const program = localParse(`const foo = func();`);
            const callExpression = program.body[0].declarations[0].init;
            const identifier = callExpression.callee;
            expect(isIdentifierDefined(identifier, callExpression, 'func')).toBe(false);
        });
        it('should return false for non-Identifier node types', () => {
            const program = localParse(`const foo = 'bar';`);
            const literal = program.body[0].declarations[0].init;
            expect(isIdentifierDefined(literal, null, 'bar')).toBe(false);
        });
    });
    describe('isFunctionInvoked', () => {
        it('should return true for CallExpression with matching function name', () => {
            const program = localParse(`const result = myFunction();`);
            const callExpression = program.body[0].declarations[0].init;
            expect(isFunctionInvoked(callExpression, 'myFunction')).toBe(true);
            expect(isFunctionInvoked(callExpression, 'otherFunction')).toBe(false);
        });
        it('should return false for CallExpression with member expression callee', () => {
            const program = localParse(`const result = obj.method();`);
            const callExpression = program.body[0].declarations[0].init;
            expect(isFunctionInvoked(callExpression, 'method')).toBe(false);
        });
        it('should return false for non-CallExpression node types', () => {
            const program = localParse(`const foo = 'bar';`);
            const literal = program.body[0].declarations[0].init;
            expect(isFunctionInvoked(literal, 'bar')).toBe(false);
        });
        it('should return false for CallExpression without callee name', () => {
            const mockCallExpression = {
                type: 'CallExpression',
                callee: { type: 'Literal', value: 'test' },
            };
            expect(isFunctionInvoked(mockCallExpression, 'test')).toBe(false);
        });
    });
});
