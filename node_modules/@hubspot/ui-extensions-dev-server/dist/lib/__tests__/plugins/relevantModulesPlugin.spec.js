import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import relevantModulesPlugin, { getRelevantModules, } from "../../plugins/relevantModulesPlugin.js";
describe('manifestPlugin', () => {
    let logger;
    let options;
    let bundle;
    beforeEach(() => {
        logger = {
            info: vi.fn(),
            debug: vi.fn(),
            warn: vi.fn(),
            error: vi.fn(),
        };
        options = {
            output: 'SomeFileName.js',
            logger,
        };
        bundle = {
            [options.output]: {
                moduleIds: [
                    'A.js',
                    'B.js',
                    'C.js',
                    'node_modules/lodash',
                    'node_modules/react',
                ],
            },
            // @ts-expect-error We don't need all the other fields
            empty: {
                moduleIds: [],
            },
        };
    });
    afterEach(() => {
        vi.clearAllMocks();
    });
    describe('metadata', () => {
        it('should return the correct metadata', () => {
            const plugin = relevantModulesPlugin(options);
            expect(plugin).toStrictEqual(expect.objectContaining({
                name: 'ui-extensions-relevant-modules-plugin',
                generateBundle: expect.any(Function),
            }));
        });
    });
    describe('getRelevantModules', () => {
        it('should return an empty array instead of undefined', () => {
            const actual = getRelevantModules('this property does not exist');
            expect(actual).toStrictEqual([]);
        });
    });
    describe('generateBundle', () => {
        it('should not update the relevantModules when output is not found in the bundle', () => {
            const plugin = relevantModulesPlugin(options);
            // @ts-expect-error TS thinks this isn't a function
            plugin.generateBundle({}, {
                output: 'no modules for this string',
            });
            const actual = getRelevantModules('something wrong');
            expect(actual).toStrictEqual([]);
            expect(logger.error).toBeCalledTimes(1);
            expect(logger.error).toHaveBeenCalledWith('Invalid bundle format, please try saving the extension again.  If the problem persists try restarting `hs project dev`');
        });
        it('should not update the relevantModules when moduleIds is not defined', () => {
            const plugin = relevantModulesPlugin({ output: 'empty', logger });
            // @ts-expect-error TS thinks this isn't a function
            plugin.generateBundle({}, bundle);
            const actual = getRelevantModules(options.output);
            expect(actual).toStrictEqual([]);
            expect(logger.error).toBeCalledTimes(1);
            expect(logger.error).toHaveBeenCalledWith('Unable to determine relevant files to watch, please try saving the extension again. If the problem persists try restarting `hs project dev`');
        });
        it('should update the relevantModules when generateBundle is called', () => {
            const plugin = relevantModulesPlugin(options);
            // @ts-expect-error TS thinks this isn't a function
            plugin.generateBundle({}, bundle);
            const actual = getRelevantModules(options.output);
            expect(actual).toStrictEqual(['A.js', 'B.js', 'C.js']);
        });
    });
});
