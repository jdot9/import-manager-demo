import { describe, it, expect, vi, beforeAll, afterAll, beforeEach, } from 'vitest';
import DevModeInterface from "../DevModeInterface.js";
import { cardConfig } from "./fixtures/extensionConfig.js";
import { DevServerState } from "../DevServerState.js";
import { EXPRESS_DEFAULT_PORT, EXPRESS_SERVER_ID, PLATFORM_VERSION, } from "../constants.js";
import { urls } from "./fixtures/urls.js";
import { localConfig } from "../__mocks__/config.js";
vi.mock('../config.ts', () => ({
    loadLocalConfig: vi.fn(() => localConfig),
    buildSourceId: vi.fn(),
    getUrlSafeFileName: vi.fn(),
}));
vi.mock('../dev.ts', () => ({
    startDevMode: vi.fn(() => {
        return function () { };
    }),
}));
import { loadLocalConfig } from "../config.js";
import { startDevMode } from "../dev.js";
const accountId = 12345;
describe('DevModeUnifiedInterface', () => {
    let consoleMock;
    let logger;
    beforeAll(() => {
        consoleMock = vi.spyOn(console, 'log').mockImplementation(() => undefined);
    });
    beforeEach(() => {
        vi.clearAllMocks();
        DevModeInterface._reset();
        DevModeInterface.logger = logger;
        logger = {
            info: vi.fn(),
            debug: vi.fn(),
            warn: vi.fn(),
            error: vi.fn(),
        };
        DevModeInterface.logger = logger;
    });
    afterAll(() => {
        consoleMock.mockRestore();
    });
    describe('start', () => {
        it('should not start the dev server again if it has already been started', () => {
            const requestPorts = vi.fn();
            DevModeInterface.isRunning = true;
            DevModeInterface.start({ requestPorts });
            expect(logger.debug).toHaveBeenCalledWith('Dev server is already running, not starting again');
            expect(requestPorts).not.toHaveBeenCalled();
        });
        it('should use the values returned from requestPorts for the service ports', async () => {
            DevModeInterface.configs = [cardConfig];
            DevModeInterface.urls = urls;
            const ports = {
                [EXPRESS_SERVER_ID]: 8675309,
            };
            const requestPorts = vi.fn().mockReturnValue(ports);
            await DevModeInterface.start({
                accountId,
                requestPorts,
            });
            expect(requestPorts).toHaveBeenCalledTimes(1);
            expect(DevModeInterface.devServerState.expressPort).toBe(ports[EXPRESS_SERVER_ID]);
        });
        it('should use the default ports when the call to requestPorts fails', async () => {
            DevModeInterface.logger = logger;
            DevModeInterface.configs = [cardConfig];
            DevModeInterface.urls = urls;
            const requestPorts = vi.fn().mockImplementation(() => {
                throw new Error("AH AH AH, YOU DIDN'T SAY THE MAGIC WORD");
            });
            await DevModeInterface.start({
                accountId,
                requestPorts,
            });
            expect(requestPorts).toHaveBeenCalledTimes(1);
            expect(logger.debug).toHaveBeenCalledWith('Call to port manager failed, using default ports');
            expect(DevModeInterface.devServerState.expressPort).toBe(EXPRESS_DEFAULT_PORT);
        });
        it('should load the local config', async () => {
            DevModeInterface.configs = [cardConfig];
            DevModeInterface.urls = urls;
            const accountId = 12345;
            await DevModeInterface.start({
                accountId,
            });
            expect(loadLocalConfig).toHaveBeenCalledTimes(1);
            expect(loadLocalConfig).toHaveBeenCalledWith(DevModeInterface.configs[0].path, DevModeInterface.logger);
            expect(DevModeInterface.devServerState?.localDevUrlMapping).toEqual(localConfig.proxy);
        });
        it('should not call startDevMode if it is unable to load the extension config', async () => {
            DevModeInterface.configs = undefined;
            const errorMessage = 'Unable to load the required extension configuration files';
            await expect(DevModeInterface.start({})).rejects.toThrowError(errorMessage);
            expect(startDevMode).not.toHaveBeenCalled();
        });
        it('should call startDevMode', async () => {
            DevModeInterface.configs = [cardConfig];
            DevModeInterface.logger = logger;
            DevModeInterface.urls = urls;
            await DevModeInterface.start({
                accountId,
            });
            const expectedState = new DevServerState({
                localDevUrlMapping: localConfig.proxy,
                extensionConfigs: [cardConfig],
                accountId,
                platformVersion: PLATFORM_VERSION.V20231,
                expressPort: EXPRESS_DEFAULT_PORT,
                logger,
                urls,
                appConfig: cardConfig.appConfig,
            });
            expect(startDevMode).toHaveBeenCalledTimes(1);
            expect(startDevMode).toHaveBeenCalledWith(expectedState);
        });
        it('should assign the method returned from startDevMode to shutdown', async () => {
            DevModeInterface.configs = [cardConfig];
            DevModeInterface.urls = urls;
            const shutdown = async () => { };
            vi.mocked(startDevMode).mockImplementationOnce(async () => shutdown);
            DevModeInterface.isRunning = false;
            await DevModeInterface.start({});
            expect(DevModeInterface.shutdown).toStrictEqual(shutdown);
        });
    });
    describe('fileChange', () => {
        it('should call onUploadRequired when it is defined and a cardConfig is edited', () => {
            const cardConfigPath = cardConfig.extensionConfigPath;
            DevModeInterface.devServerState = new DevServerState({
                extensionConfigs: [cardConfig],
                accountId,
                expressPort: 1234,
                platformVersion: PLATFORM_VERSION.V20251,
                logger,
                urls,
            });
            DevModeInterface.onUploadRequired = vi.fn();
            DevModeInterface.fileChange(cardConfigPath, '');
            expect(DevModeInterface.onUploadRequired).toHaveBeenCalledTimes(1);
        });
        it('should not call onUploadRequired when it is not a card config', () => {
            DevModeInterface.devServerState = undefined;
            DevModeInterface.onUploadRequired = vi.fn();
            DevModeInterface.fileChange('some/other/file.jsx', '');
            expect(DevModeInterface.onUploadRequired).not.toHaveBeenCalled();
        });
        it('should not call onUploadRequired extensionConfigPath is undefined', () => {
            DevModeInterface.onUploadRequired = vi.fn();
            DevModeInterface.fileChange('some/other/file.jsx', '');
            expect(DevModeInterface.onUploadRequired).not.toHaveBeenCalled();
        });
    });
    describe('cleanup', () => {
        it('should call shutdown when cleanup is invoked', async () => {
            const shutdown = vi
                .fn()
                .mockImplementation(() => Promise.resolve());
            DevModeInterface.isRunning = true;
            DevModeInterface.shutdown = shutdown;
            await DevModeInterface.cleanup();
            expect(shutdown).toHaveBeenCalledTimes(1);
        });
        it('should reset the dev server state', async () => {
            const shutdown = vi
                .fn()
                .mockImplementation(() => Promise.resolve());
            DevModeInterface.isRunning = true;
            DevModeInterface.shutdown = shutdown;
            await DevModeInterface.cleanup();
            expect(DevModeInterface.configs).toBeUndefined();
            expect(DevModeInterface.devServerState).toBeUndefined();
            expect(DevModeInterface.onUploadRequired).toBeUndefined();
            expect(DevModeInterface.shutdown).toBeUndefined();
            expect(DevModeInterface.urls).toBeUndefined();
            expect(DevModeInterface.isConfigured).toBe(false);
            expect(DevModeInterface.isRunning).toBe(false);
        });
    });
});
