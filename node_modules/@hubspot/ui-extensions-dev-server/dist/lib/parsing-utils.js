/**
 * Extracts the value from a given AST node based on its type.
 * This function handles various node types such as Literal, Identifier (aka variables), ArrayExpression,
 * ObjectExpression, SpreadElement, TemplateLiteral, UnaryExpression, and MemberExpression (accessing props on objects).
 * It also supports nested structures and handles special cases like undefined, NaN, and Infinity.
 *
 * It does not handle function calls, complex expressions, or anything that requires evaluation of code logic.
 * This is not a full JavaScript interpreter, but rather a utility to extract static values from the AST.
 *
 * Use this function carefully, as it assumes that the AST is well-formed and that the node types are as expected.
 * Many types are not yet supported. Anything this function is used for should have a backup runtime evaluation,
 * or be set up to fail gracefully if parsing fails.
 *
 * @param node - The AST node from which to extract the value.
 * @param state - The current state of the source code metadata, including variable declarations.
 * @returns An object containing the status of the operation, the extracted node value,
 *          or an error message if the extraction fails.
 *          The status can be 'SUCCESS' or 'FAIL'.
 *          If the status is 'SUCCESS', nodeValue will contain the extracted value.
 *          If the status is 'FAIL', error will contain the error message.
 */
export function getValueFromNode(node, state) {
    try {
        switch (node.type) {
            case 'Literal':
                return { status: 'SUCCESS', nodeValue: node.value };
            case 'Identifier': {
                const name = node.name;
                switch (name) {
                    case 'undefined':
                        return { status: 'SUCCESS', nodeValue: undefined };
                    case 'NaN':
                        return { status: 'SUCCESS', nodeValue: NaN };
                    case 'Infinity':
                        return { status: 'SUCCESS', nodeValue: Infinity };
                    default:
                        if (state.variableDeclarations.has(name)) {
                            return {
                                status: 'SUCCESS',
                                nodeValue: state.variableDeclarations.get(name),
                            };
                        }
                        // If for some reason the variable tracking fails, return unsupported.
                        return { status: 'FAIL', error: `Identifier ${name} is not found` };
                }
            }
            case 'ArrayExpression': {
                const arrayValue = [];
                if (node.elements.length === 0) {
                    return { status: 'SUCCESS', nodeValue: arrayValue };
                }
                // Arrays have to be built from their elements, to handle special cases like nested arrays from spread operators.
                for (const element of node.elements) {
                    if (typeof element === 'object' && element !== null) {
                        if (element.type === 'SpreadElement') {
                            const result = getValueFromNode(element, state);
                            if (result.status === 'FAIL') {
                                return {
                                    status: 'FAIL',
                                    error: `Array spread element failed: ${result.error}`,
                                };
                            }
                            const value = result.nodeValue;
                            if (Array.isArray(value)) {
                                arrayValue.push(...value);
                            }
                            else {
                                arrayValue.push(value);
                            }
                        }
                        else {
                            const result = getValueFromNode(element, state);
                            if (result.status === 'FAIL') {
                                return {
                                    status: 'FAIL',
                                    error: `Array element failed: ${result.error}`,
                                };
                            }
                            arrayValue.push(result.nodeValue);
                        }
                    }
                    else {
                        arrayValue.push(element);
                    }
                }
                return { status: 'SUCCESS', nodeValue: arrayValue };
            }
            case 'ObjectExpression': {
                const obj = {};
                for (const prop of node.properties) {
                    switch (prop.type) {
                        case 'Property': {
                            const property = prop;
                            let key = undefined;
                            if (property.key.type === 'Identifier') {
                                key = property.key.name;
                            }
                            else if (property.key.type === 'Literal') {
                                key = String(property.key.value);
                            }
                            if (key) {
                                const result = getValueFromNode(property.value, state);
                                if (result.status === 'FAIL') {
                                    return {
                                        status: 'FAIL',
                                        error: `Object property '${key}' failed: ${result.error}`,
                                    };
                                }
                                obj[key] = result.nodeValue;
                            }
                            break;
                        }
                        case 'SpreadElement': {
                            const result = getValueFromNode(prop, state);
                            if (result.status === 'FAIL') {
                                return {
                                    status: 'FAIL',
                                    error: `Object spread element failed: ${result.error}`,
                                };
                            }
                            const spreadValue = result.nodeValue;
                            if (spreadValue && typeof spreadValue === 'object') {
                                Object.assign(obj, spreadValue);
                            }
                            break;
                        }
                        default:
                            // Ignore unsupported property types, as we don't have a key for them.
                            // This could be a computed property or something else we don't handle.
                            break;
                    }
                }
                return { status: 'SUCCESS', nodeValue: obj };
            }
            /**
             * Spread elements are a bit tricky. They can be used to directly spread an array or object,
             * or they can be used to spread a variable that is defined elsewhere. Our strategy is to return
             * whatever element should be spread, and then handle the spreading in the parent array or object.
             *
             * There are also trickier cases we don't handle, like spreading a function call that returns an
             * array or object. When the spread element is unsupported, we return a special symbol.
             */
            case 'SpreadElement':
                if (node.argument) {
                    if (node.argument.type === 'Identifier' && node.argument.name) {
                        return {
                            status: 'SUCCESS',
                            nodeValue: state.variableDeclarations.get(node.argument.name) || null,
                        };
                    }
                    else if (node.argument.type === 'ArrayExpression' ||
                        node.argument.type === 'ObjectExpression') {
                        return getValueFromNode(node.argument, state);
                    }
                }
                return {
                    status: 'FAIL',
                    error: `Unsupported SpreadElement type: ${node.argument.type}`,
                };
            /**
             * Template literals are built of an alternating sequence of static
             * strings and expressions. We will concatenate the static strings and
             * evaluate the expressions to build the final string.
             */
            case 'TemplateLiteral': {
                let result = '';
                if (node.expressions && node.quasis) {
                    const { quasis, expressions } = node;
                    for (let i = 0; i < quasis.length; i++) {
                        // Prefer cooked value if available, otherwise use raw.
                        result += quasis[i].value.cooked || quasis[i].value.raw;
                        if (i < expressions.length) {
                            const expression = expressions[i];
                            const expressionResult = getValueFromNode(expression, state);
                            if (expressionResult.status === 'SUCCESS') {
                                const expressionValue = expressionResult.nodeValue;
                                if (expressionValue === null ||
                                    expressionValue === undefined ||
                                    typeof expressionValue === 'string' ||
                                    typeof expressionValue === 'number' ||
                                    typeof expressionValue === 'boolean') {
                                    result += String(expressionValue);
                                }
                                else if (Array.isArray(expressionValue)) {
                                    result += expressionValue.join(',');
                                }
                                else if (typeof expressionValue === 'object') {
                                    result += '[object Object]';
                                }
                                else {
                                    result += `Unsupported TemplateLiteral expression value type: ${typeof expressionValue}`;
                                }
                            }
                            else {
                                result += expressionResult.error;
                            }
                        }
                    }
                }
                return { status: 'SUCCESS', nodeValue: result };
            }
            case 'UnaryExpression': {
                const argResult = getValueFromNode(node.argument, state);
                if (argResult.status === 'FAIL') {
                    return argResult;
                }
                const arg = argResult.nodeValue;
                switch (node.operator) {
                    case '-':
                        return {
                            status: 'SUCCESS',
                            nodeValue: typeof arg === 'number' ? -arg : NaN,
                        };
                    case '+':
                        return {
                            status: 'SUCCESS',
                            nodeValue: typeof arg === 'number' ? +arg : NaN,
                        };
                    case '!':
                        return { status: 'SUCCESS', nodeValue: !arg };
                    case 'typeof':
                        return { status: 'SUCCESS', nodeValue: typeof arg };
                    default:
                        return {
                            status: 'FAIL',
                            error: `Unsupported unary operator: ${node.operator}`,
                        };
                }
            }
            // Member expressions are used to access properties of objects.
            case 'MemberExpression': {
                if (node.property.type === 'Identifier' && node.property.name) {
                    // We have to recursively get the value of the object, due to the way that nested objects are parsed.
                    const objectResult = getValueFromNode(node.object, state);
                    if (objectResult.status === 'FAIL') {
                        return objectResult;
                    }
                    const objectData = objectResult.nodeValue;
                    if (objectData &&
                        typeof objectData === 'object' &&
                        !Array.isArray(objectData) &&
                        !(objectData instanceof RegExp)) {
                        return {
                            status: 'SUCCESS',
                            nodeValue: objectData[node.property.name],
                        };
                    }
                }
                return {
                    status: 'FAIL',
                    error: `Unsupported MemberExpression property type: ${node.property.type}`,
                };
            }
            default:
                return { status: 'FAIL', error: `Unsupported node type: ${node.type}` };
        }
    }
    catch (error) {
        return {
            status: 'FAIL',
            error: error instanceof Error ? error.message : String(error),
        };
    }
}
export function isVariableImported(node, variableName) {
    if (!node) {
        return false;
    }
    return ((node.type === 'ImportSpecifier' &&
        node.imported.type === 'Identifier' &&
        node.imported.name === variableName) ||
        (node.type === 'ImportDefaultSpecifier' &&
            node.local.name === variableName) ||
        (node.type === 'ImportNamespaceSpecifier' &&
            node.local.name === variableName));
}
export function isIdentifierDefined(node, parent, name) {
    if (parent &&
        (parent.type === 'MemberExpression' || parent.type === 'CallExpression')) {
        return false;
    }
    return node.type === 'Identifier' && node.name === name;
}
export function isFunctionInvoked(node, functionName) {
    return (node.type === 'CallExpression' &&
        node.callee &&
        'name' in node.callee &&
        node.callee.name === functionName);
}
