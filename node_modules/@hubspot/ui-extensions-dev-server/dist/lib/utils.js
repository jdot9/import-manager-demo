import path from 'path';
import fs from 'fs';
import { MANIFEST_FILE } from "./constants.js";
export function getUrlSafeFileName(filePath) {
    const { name } = path.parse(filePath);
    return encodeURIComponent(`${name}.js`);
}
// Strips ANSI color codes out of strings because we don't want to pass them to the browser
export function stripAnsiColorCodes(stringWithColorCodes) {
    if (!stringWithColorCodes) {
        return null;
    }
    return stringWithColorCodes.replace(
    // eslint-disable-next-line no-control-regex
    /[\u001b][[]*([0-9]{1,4};?)*[m]/g, '');
}
export function loadManifest(outputDir, output) {
    try {
        return JSON.parse(fs
            .readFileSync(path.join(outputDir, `${output}-${MANIFEST_FILE}`))
            .toString());
    }
    catch (e) {
        return {};
    }
}
export function buildSourceId(appConfig, extensionConfig) {
    if (appConfig.uid && extensionConfig.data.uid) {
        return `${appConfig.uid}::${extensionConfig.data.uid}`;
    }
    return null;
}
export function isNodeModule(filepath) {
    if (!filepath) {
        return false;
    }
    const directory = path.parse(filepath).dir;
    return directory.includes('node_modules');
}
/**
 * Check if a given file is within the extension path
 */
export function isExtensionFile(filepath, extensionPath) {
    if (!filepath) {
        return false;
    }
    try {
        const absoluteFilePath = fs.realpathSync(filepath);
        const absoluteExtensionDirPath = fs.realpathSync(extensionPath);
        const relativePath = path.relative(absoluteExtensionDirPath, absoluteFilePath);
        return !relativePath.startsWith('..') && !path.isAbsolute(relativePath);
    }
    catch (e) {
        console.log(`Error checking if ${filepath} is in extension path: ${e}`);
        // If there's an error, we can't determine if the file is in the extension path, so return false.
        return false;
    }
}
export class UnhandledPlatformVersionError extends Error {
    constructor(platformVersion) {
        super(`Unsupported platform version "${platformVersion}"`);
    }
}
export function throwUnhandledPlatformVersionError(platformVersion) {
    throw new UnhandledPlatformVersionError(platformVersion);
}
export function extractAllowedUrls(appConfig) {
    if (!appConfig || !('allowedUrls' in appConfig) || !appConfig.allowedUrls) {
        return [];
    }
    return appConfig.allowedUrls;
}
function simpleHash(input) {
    let hash = 0;
    for (let i = 0; i < input.length; i++) {
        const char = input.charCodeAt(i);
        hash = (hash * 31 + char) % 2147483647;
    }
    return Math.abs(hash).toString(16);
}
/**
 * This function generates a deterministic hash from any number of arguments
 * Arrays and objects are stringified to ensure it works for all types.
 * Uses the same simple hash algorithm as the browser version for consistency.
 */
export function generateHash(...args) {
    try {
        // First make sure all the values are strings
        const normalizedArgs = args.map((arg) => {
            if (Array.isArray(arg)) {
                return [...arg].sort().join('-');
            }
            if (arg && typeof arg === 'object') {
                return JSON.stringify(arg, Object.keys(arg).sort());
            }
            return String(arg);
        });
        // Return the hash of the joined strings.
        const input = [...normalizedArgs].join('::');
        return simpleHash(input);
    }
    catch (e) {
        console.error('Error generating hash: ', e);
        // Just return an empty string if anything goes wrong.
        return '';
    }
}
/**
 * Check if a given URL is an image (of a type we support)
 */
export function isImage(url) {
    return /\.(png|jpg|jpeg|gif|svg|webp|avif|raw|url|inline)$/.test(url);
}
