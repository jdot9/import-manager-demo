import { ROLLUP_OPTIONS, WEBSOCKET_MESSAGE_VERSION } from "../constants.js";
import { build } from 'vite';
import manifestPlugin from "./manifestPlugin.js";
import { stripAnsiColorCodes } from "../utils.js";
import codeCheckingPlugin from "./codeCheckingPlugin.js";
import path from 'path';
import friendlyLoggingPlugin from "./friendlyLoggingPlugin.js";
import relevantModulesPlugin, { getRelevantModules, } from "./relevantModulesPlugin.js";
import codeBlockingPlugin from "./codeBlockingPlugin.js";
function addVersionToBaseMessage(baseMessage) {
    return {
        ...baseMessage,
        version: WEBSOCKET_MESSAGE_VERSION,
    };
}
function isValidVariablesRecord(obj) {
    if (!obj || typeof obj !== 'object')
        return false;
    return Object.entries(obj).every(([key, value]) => typeof key === 'string' &&
        (typeof value === 'string' ||
            typeof value === 'number' ||
            typeof value === 'boolean'));
}
const devBuildPlugin = (options) => {
    const { devServerState } = options;
    const { logger } = devServerState;
    let lastBuildErrorContext;
    const handleBuildError = (error) => {
        const { error: { plugin, errors, frame, loc, id }, extensionMetadata, } = error;
        // Filter out our custom plugins, but send everything else
        if (!plugin?.startsWith('ui-extensions')) {
            devServerState.getExtensionsWebSocket().broadcast({
                ...addVersionToBaseMessage(extensionMetadata.baseMessage),
                event: 'error',
                error: {
                    details: {
                        errors,
                        formattedError: stripAnsiColorCodes(frame),
                        location: loc,
                        file: id,
                    },
                },
            });
        }
    };
    const devBuild = async (server, extensionMetadata, emptyOutDir = false) => {
        try {
            const { config: extensionConfig } = extensionMetadata;
            const { extensionPath } = extensionConfig;
            let manifestConfig = {};
            if (devServerState.appConfig &&
                'variables' in devServerState.appConfig &&
                isValidVariablesRecord(devServerState.appConfig.variables)) {
                manifestConfig = {
                    variables: devServerState.appConfig.variables,
                };
            }
            await build({
                logLevel: 'warn',
                mode: 'development',
                define: {
                    'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV || 'development'),
                },
                esbuild: {
                    tsconfigRaw: {
                        compilerOptions: {
                            preserveValueImports: true,
                        },
                    },
                },
                build: {
                    lib: {
                        entry: extensionConfig.data.module.file,
                        name: extensionConfig.output,
                        formats: ['iife'],
                        fileName: () => extensionConfig.output,
                    },
                    rollupOptions: {
                        ...ROLLUP_OPTIONS,
                        plugins: [
                            manifestPlugin({
                                minify: false,
                                output: extensionConfig.output,
                                extensionPath,
                                logger,
                                manifestConfig,
                            }),
                            codeCheckingPlugin({
                                output: path.join(devServerState.outputDir, extensionConfig.output),
                                logger,
                            }),
                            friendlyLoggingPlugin({ logger }),
                            relevantModulesPlugin({
                                output: extensionConfig.output,
                                logger,
                            }),
                            codeBlockingPlugin({ logger, extensionPath }),
                        ],
                        output: {
                            ...ROLLUP_OPTIONS.output,
                        },
                    },
                    outDir: devServerState.outputDir,
                    emptyOutDir,
                    minify: false,
                    sourcemap: 'inline',
                },
                clearScreen: false,
            });
            lastBuildErrorContext = null;
            return true;
        }
        catch (error) {
            lastBuildErrorContext = {
                error: error,
                extensionMetadata,
            };
            logger.debug(error);
            handleBuildError(lastBuildErrorContext);
            return false;
        }
    };
    let localServer;
    return {
        name: 'ui-extensions-dev-build-plugin',
        enforce: 'pre',
        configureServer: async (server) => {
            // Store a reference to the server to be used in hooks that don't get the server injected
            // See https://vitejs.dev/guide/api-plugin.html#configureserver for information on this pattern
            localServer = server;
            // Store the WebSocket setup to be called after the WebSocket is initialized
            devServerState.setWebSocketSetupCallback(() => {
                devServerState.getExtensionsWebSocket().onConnection(() => {
                    logger.info('Browser connected and listening for bundle updates');
                    devServerState.extensionsMetadata.forEach((metadata) => {
                        devServerState.getExtensionsWebSocket().broadcast({
                            ...addVersionToBaseMessage(metadata.baseMessage),
                            event: 'start',
                        });
                    });
                    if (lastBuildErrorContext) {
                        handleBuildError(lastBuildErrorContext);
                    }
                });
            });
            for (let i = 0; i < devServerState.extensionsMetadata.length; ++i) {
                await devBuild(localServer, devServerState.extensionsMetadata[i], i === 0);
            }
        },
        handleHotUpdate: async ({ file, server }) => {
            // If the file is not in the relevantModules list, it's update is inconsequential
            const extensionsToRebuild = devServerState.extensionsMetadata.filter((metadata) => {
                const { config } = metadata;
                return getRelevantModules(config.output).includes(file);
            });
            for (let i = 0; i < extensionsToRebuild.length; ++i) {
                const toRebuild = extensionsToRebuild[i];
                const successful = await devBuild(server, toRebuild);
                if (!successful) {
                    return [];
                }
                const { config: extensionConfig } = toRebuild;
                logger.info(`Extension ${extensionConfig.data.title} updated, compiled`);
                const ws = devServerState.getExtensionsWebSocket();
                if (ws.clientCount === 0) {
                    logger.debug('Bundle updated, no browsers connected to notify');
                    return [];
                }
                logger.debug('Bundle updated, notifying connected browsers');
                ws.broadcast({
                    ...addVersionToBaseMessage(toRebuild.baseMessage),
                    event: 'update',
                });
            }
            return [];
        },
        buildEnd(error) {
            if (error) {
                logger.error(error);
            }
            const ws = devServerState.extensionsWebSocket;
            if (ws) {
                logger.debug('Sending shutdown message to connected browsers');
                devServerState.extensionsMetadata.forEach((metadata) => {
                    ws.broadcast({
                        ...addVersionToBaseMessage(metadata.baseMessage),
                        event: 'shutdown',
                    });
                });
            }
        },
    };
};
export default devBuildPlugin;
