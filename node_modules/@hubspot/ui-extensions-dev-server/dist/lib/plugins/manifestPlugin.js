import { readFileSync } from 'fs';
import { normalize } from 'path';
import { MANIFEST_FILE } from "../constants.js";
import path from 'path';
import { isExtensionFile, isNodeModule } from "../utils.js";
import { traverseAbstractSyntaxTree } from "../ast.js";
const PACKAGE_LOCK_FILE = 'package-lock.json';
const PACKAGE_FILE = 'package.json';
/**
 * Checks if a given filename is a valid module file path. This is necessary because
 * Rollup sometimes passes in a filename that starts with a null byte, which is not a valid
 * module file path. From the Rollup documentation:
 *
 * > If your plugin uses 'virtual modules' (e.g. for helper functions), prefix the module ID with \0.
 * > This prevents other plugins from trying to process it.
 * Source: https://rollupjs.org/plugin-development/#conventions
 *
 * @param filename The filename to check.
 * @returns Whether the filename is a valid module file path.
 */
const isRealModuleFile = (filename) => typeof filename === 'string' && !filename.startsWith('\0');
const manifestPlugin = (options) => {
    let allDataDependencies;
    return {
        name: 'ui-extensions-manifest-generation-plugin',
        enforce: 'post', // run after default rollup plugins
        buildStart() {
            // Reset the source metadata for the new build
            allDataDependencies = [];
        },
        transform(code, filename) {
            const { logger } = options;
            // We only need to parse the AST for extension files, so check that first.
            const isExtension = isRealModuleFile(filename) &&
                isExtensionFile(filename, options.extensionPath || '');
            if (!isExtension) {
                return { code, map: null };
            }
            try {
                const ast = this.parse(code);
                const sourceCodeMetadata = traverseAbstractSyntaxTree(ast, [], options.extensionPath || process.cwd(), logger);
                allDataDependencies = [
                    ...allDataDependencies,
                    ...sourceCodeMetadata.dataDependencies.dependencies,
                ];
            }
            catch (e) {
                logger.error(`Unable to parse source code for ${filename}, ${e}`);
            }
            // We don't need to actually transform anything, just collect data, so return the original code
            return { code, map: null };
        },
        generateBundle(_rollupOptions, bundle) {
            const { output, minify = false, extensionPath = process.cwd(), logger, } = options;
            try {
                const filename = path.parse(output).name;
                const manifest = _generateManifestContents(bundle, extensionPath, allDataDependencies, options?.manifestConfig);
                this.emitFile({
                    type: 'asset',
                    source: minify
                        ? JSON.stringify(manifest)
                        : JSON.stringify(manifest, null, 2),
                    fileName: normalize(`${filename}-${MANIFEST_FILE}`),
                });
            }
            catch (e) {
                logger.warn(`\nUnable to write manifest file in ${output}, ${e}`);
            }
        },
    };
};
function _generateManifestContents(bundle, extensionPath, allDataDependencies, appConfig) {
    const baseManifest = {
        package: _loadPackageFile(extensionPath),
    };
    const dataDependencies = {
        dataDeps: allDataDependencies ?? [],
    };
    const variables = {
        variables: {},
    };
    if (appConfig &&
        'variables' in appConfig &&
        typeof appConfig.variables === 'object' &&
        appConfig.variables !== null) {
        variables.variables = appConfig.variables;
    }
    // The keys to bundle are the filename without any path information
    const bundles = Object.keys(bundle).filter((cur) => cur.endsWith('.js'));
    if (bundles.length === 1) {
        return {
            ..._generateManifestEntry(bundle[bundles[0]], extensionPath),
            ...dataDependencies,
            ...baseManifest,
            ...variables,
        };
    }
    const manifest = bundles.reduce((acc, current) => {
        return {
            ...acc,
            [current]: _generateManifestEntry(bundle[current], extensionPath),
        };
    }, {});
    return {
        ...manifest,
        ...dataDependencies,
        ...baseManifest,
        ...variables,
    };
}
function _generateManifestEntry(subBundle, extensionPath) {
    const { facadeModuleId, moduleIds, modules } = subBundle;
    return {
        entry: _stripPathPriorToExtDir(facadeModuleId, extensionPath),
        modules: _buildModulesInfo(moduleIds, modules, extensionPath),
    };
}
function _loadJsonFileSafely(extensionPath, filename) {
    try {
        return JSON.parse(readFileSync(path.join(extensionPath, filename)).toString());
    }
    catch (e) {
        return undefined;
    }
}
function _loadPackageFile(extensionPath) {
    // Look for package-lock.json then fallback to package.json
    return (_loadJsonFileSafely(extensionPath, PACKAGE_LOCK_FILE) ||
        _loadJsonFileSafely(extensionPath, PACKAGE_FILE));
}
function _stripPathPriorToExtDir(filepath, extensionPath) {
    // Before stripping the path, make sure the given extensionPath ends with a slash.
    extensionPath = extensionPath.endsWith('/')
        ? extensionPath
        : `${extensionPath}/`;
    return filepath?.split(extensionPath).pop();
}
function _buildModulesInfo(moduleIds, modules, extensionPath) {
    const accumulator = {
        internal: [],
        external: [],
    };
    return moduleIds.reduce((acc, mod) => {
        const { renderedExports } = modules[mod];
        const moduleData = {
            module: _stripPathPriorToExtDir(mod, extensionPath),
            renderedExports,
        };
        if (isNodeModule(moduleData.module)) {
            acc.external.push(moduleData);
        }
        else {
            acc.internal.push(moduleData);
        }
        return acc;
    }, accumulator);
}
export default manifestPlugin;
