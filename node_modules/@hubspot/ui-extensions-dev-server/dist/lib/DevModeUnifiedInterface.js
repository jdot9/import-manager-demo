import path from 'path';
import { SUPPORTED_EXTENSION_TYPES } from "./constants.js";
import { UnifiedComponentTypes, } from "./types.js";
import { DevModeParentInterface } from "./DevModeParentInterface.js";
import { getUrlSafeFileName } from "./utils.js";
function getComponentName(componentType) {
    if (componentType === UnifiedComponentTypes.SETTINGS) {
        return 'Settings';
    }
    if (componentType === UnifiedComponentTypes.PAGE) {
        return 'App Home';
    }
}
class DevModeUnifiedInterface extends DevModeParentInterface {
    _generateAppExtensionMappings(components, profileData) {
        const mappings = [];
        // Loop over all of the components that are passed in
        const allComponentUids = Object.keys(components);
        // Find the app component
        const appUid = allComponentUids.find((componentUid) => {
            return (components[componentUid].componentType ===
                UnifiedComponentTypes.APPLICATION);
        });
        // This should fail a lot sooner (on the cli side), but added this just in case.
        if (!appUid) {
            // TODO: Add this once logger is set up on parent class
            // this.logger.error('Application configuration is missing.');
            return mappings;
        }
        const appData = components[appUid];
        // Use the app data to generate the app config in the expected shape, to match old projects.
        const appConfig = {
            name: appData.config.name,
            description: appData.config?.description,
            uid: appData.uid,
            extensions: {
                crm: {
                    cards: [],
                },
            },
            auth: appData.config?.auth,
            support: appData.config?.support,
            // All unified apps are currently "public" meaning they don't support serverless and do support a proxy.
            // The determination of what is "public" and "private" as it relates to our usage is still up in the air.
            isPublicApp: true,
            allowedUrls: appData.config?.permittedUrls
                ? Object.values(appData.config.permittedUrls).flat()
                : [],
            variables: profileData || {},
        };
        // Then get all the supported extensions
        const extensionUids = allComponentUids.filter((componentUid) => {
            return SUPPORTED_EXTENSION_TYPES.includes(components[componentUid].componentType);
        });
        // Build the extension mapping data
        extensionUids.forEach((extensionUid) => {
            const extension = components[extensionUid];
            // Update the extension entrypoint to be "relative" to the extension directory (eg from /app/card/card.jsx to ./card.jsx)
            extension.config.entrypoint = `./${path.basename(extension.config.entrypoint)}`;
            // Hardcode the extension name if this is a settings extension (the user does not provide a name for their settings card).
            if (extension.componentType === UnifiedComponentTypes.SETTINGS ||
                extension.componentType === UnifiedComponentTypes.PAGE) {
                extension.config.name = getComponentName(extension.componentType) ?? '';
            }
            // Add them to the app config
            switch (extension.componentType) {
                case UnifiedComponentTypes.CARD:
                default:
                    appConfig.extensions.crm.cards.push({
                        file: extension.config.entrypoint,
                    });
            }
            // Generate the name and other extension data for the mapping.
            const extensionName = `${appData.config.name}/${extension.config.name}`;
            const extensionOutput = getUrlSafeFileName(path.resolve(extension.localDev.componentRoot, extension.config.entrypoint));
            const filePath = path.resolve(extension.localDev.componentRoot, extension.config.entrypoint);
            // Build the config in the correct shape
            const extensionData = {
                title: extension.config.name,
                uid: extension.uid,
                location: extension.config.location,
                module: {
                    file: filePath,
                },
                objectTypes: [],
                appName: appData.config.name,
                sourceId: `${appConfig.uid}::${extension.uid}`,
            };
            // Generate object types
            if (extension.config.objectTypes) {
                extension.config.objectTypes.forEach((objectType) => {
                    extensionData.objectTypes.push({
                        name: objectType,
                    });
                });
            }
            mappings.push({
                name: extensionName,
                value: {
                    type: extension.componentType.toLowerCase(),
                    data: extensionData,
                    output: extensionOutput,
                    path: appData.localDev.componentRoot,
                    extensionPath: extension.localDev.componentRoot,
                    extensionConfigPath: extension.localDev.componentConfigPath,
                    appConfig,
                },
            });
        });
        return mappings;
    }
    async setup(args) {
        args.choices = this._generateAppExtensionMappings(args.components, args.profileData ?? {});
        await this.parentSetup(args);
    }
}
export { DevModeUnifiedInterface as DevModeUnifiedInterfaceNonSingleton };
export default new DevModeUnifiedInterface();
