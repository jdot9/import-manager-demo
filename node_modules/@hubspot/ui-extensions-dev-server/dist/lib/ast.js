import path from 'path';
// @ts-expect-error no type defs
import { traverse } from 'estraverse';
import { generateHash, isExtensionFile, isImage } from "./utils.js";
import { getValueFromNode, isFunctionInvoked, isIdentifierDefined, isVariableImported, } from "./parsing-utils.js";
const PARSED_HOOKS = ['useCrmProperties', 'useAssociations'];
function _checkForFunctionMetadata(node, parent, output, functionName) {
    if (!node) {
        return;
    }
    if (!output.functions[functionName]) {
        output.functions[functionName] = {};
    }
    if (isFunctionInvoked(node, functionName)) {
        output.functions[functionName].invoked = true;
        // If the function is invoked before being defined we will assume it is a global function
        output.functions[functionName].scope = output.functions[functionName]
            .defined
            ? 'Local'
            : 'Global';
    }
    else if (isIdentifierDefined(node, parent, functionName) ||
        isVariableImported(node, functionName)) {
        output.functions[functionName].defined = true;
    }
}
function _collectVariableDeclarations(node, state) {
    if (!node) {
        return;
    }
    // Handle variable declarations (const, let, var)
    if (node.type === 'VariableDeclaration') {
        node.declarations.forEach((declaration) => {
            if (declaration.type === 'VariableDeclarator' &&
                declaration.id.type === 'Identifier' &&
                declaration.init) {
                const variableName = declaration.id.name;
                const result = getValueFromNode(declaration.init, state);
                if (result.status === 'SUCCESS') {
                    state.variableDeclarations.set(variableName, result.nodeValue);
                }
            }
        });
    }
    // Handle assignment expressions for let variables (e.g., myVar = newValue)
    if (node.type === 'AssignmentExpression' && node.left.type === 'Identifier') {
        const variableName = node.left.name;
        if (state.variableDeclarations.has(variableName)) {
            const result = getValueFromNode(node.right, state);
            if (result.status === 'SUCCESS') {
                state.variableDeclarations.set(variableName, result.nodeValue);
            }
        }
    }
}
/**
 * We only support image imports that are within the extension directory.
 * This function will check if an image is out of bounds and collect any that are out of bounds, so we can warn the user before they run into build issues.
 */
export function checkForOutOfBoundsImageImports(node, output, extensionPath) {
    if (!node) {
        return;
    }
    if (node.type === 'ImportDeclaration' &&
        typeof node.source.value === 'string') {
        const importPath = node.source.value;
        // Only do the check for images.
        if (!isImage(importPath)) {
            return;
        }
        // Build the full path to the import, using the extension path as the base.
        const absoluteImportPath = path.resolve(extensionPath, importPath);
        if (!isExtensionFile(absoluteImportPath, extensionPath)) {
            output.badImports.push(importPath);
        }
    }
}
function _processCrmPropertiesHook(node, output) {
    if (node.type !== 'CallExpression')
        return;
    const propertyType = 'CrmRecordProperties';
    const propertiesNode = node.arguments[0];
    const optionsNode = node.arguments[1];
    const requestedProperties = [];
    const propertiesResult = propertiesNode
        ? getValueFromNode(propertiesNode, output)
        : null;
    if (propertiesResult &&
        propertiesResult.status === 'SUCCESS' &&
        Array.isArray(propertiesResult.nodeValue)) {
        propertiesResult.nodeValue.forEach((val) => {
            if (typeof val === 'string') {
                requestedProperties.push(val);
            }
        });
    }
    if (requestedProperties.length > 0) {
        let options = {};
        const optionsResult = optionsNode
            ? getValueFromNode(optionsNode, output)
            : null;
        if (optionsResult &&
            optionsResult.status === 'SUCCESS' &&
            optionsResult.nodeValue &&
            typeof optionsResult.nodeValue === 'object' &&
            !Array.isArray(optionsResult.nodeValue) &&
            !(optionsResult.nodeValue instanceof RegExp)) {
            options = optionsResult.nodeValue;
        }
        output.dataDependencies.dependencies.push({
            referenceId: generateHash(propertyType, requestedProperties),
            properties: {
                type: propertyType,
                recordProperties: requestedProperties,
                options,
            },
        });
    }
}
function _processAssociationsHook(node, output) {
    if (node.type !== 'CallExpression')
        return;
    const propertyType = 'CrmRecordAssociationProperties';
    const requestNode = node.arguments[0];
    const optionsNode = node.arguments[1];
    const requestResult = requestNode
        ? getValueFromNode(requestNode, output)
        : null;
    if (!requestResult ||
        requestResult.status === 'FAIL' ||
        !requestResult.nodeValue ||
        typeof requestResult.nodeValue !== 'object' ||
        Array.isArray(requestResult.nodeValue)) {
        return;
    }
    const request = requestResult.nodeValue;
    const toObjectTypeId = request.toObjectType;
    const requestProperties = request.properties;
    if (typeof toObjectTypeId !== 'string') {
        return;
    }
    const propertiesArray = [];
    if (requestProperties && Array.isArray(requestProperties)) {
        requestProperties.forEach((val) => {
            if (typeof val === 'string') {
                propertiesArray.push(val);
            }
        });
    }
    const paginationOptions = {};
    const otherOptions = {};
    const optionsResult = optionsNode
        ? getValueFromNode(optionsNode, output)
        : null;
    if (optionsResult &&
        optionsResult.status === 'SUCCESS' &&
        optionsResult.nodeValue &&
        typeof optionsResult.nodeValue === 'object' &&
        !Array.isArray(optionsResult.nodeValue) &&
        !(optionsResult.nodeValue instanceof RegExp)) {
        const options = optionsResult.nodeValue;
        Object.keys(options).forEach((key) => {
            otherOptions[key] = options[key];
        });
    }
    if (request.pageLength !== undefined) {
        paginationOptions.pageLength = request.pageLength;
    }
    if (request.offset !== undefined) {
        paginationOptions.offset = request.offset;
    }
    const sortedPropertiesForHash = [...propertiesArray].sort();
    output.dataDependencies.dependencies.push({
        referenceId: generateHash(propertyType, toObjectTypeId, sortedPropertiesForHash.join('-')),
        properties: {
            type: propertyType,
            toObjectTypeId,
            requestProperties: propertiesArray,
            paginationOptions,
            options: otherOptions,
        },
    });
}
/**
 * This function collects all internal data dependencies for the extension
 * Specifically, it collects dependencies which are using our custom hooks, eg `useCrmProperties`
 */
function _collectDataDependencies(node, output, logger) {
    if (!node) {
        return;
    }
    try {
        // Check for imports of our hooks.
        if (node.type === 'ImportDeclaration' &&
            typeof node.source.value === 'string' &&
            node.source.value.startsWith('@hubspot/ui-extensions')) {
            // If the imports are coming from our own package, loop over them to check for hooks
            node.specifiers.forEach((specifier) => {
                // If the specifier is an ImportSpecifier and the imported name is one of our tracked hooks, we will track it.
                if (specifier.type === 'ImportSpecifier' &&
                    specifier.imported.type === 'Identifier' &&
                    PARSED_HOOKS.includes(specifier.imported.name)) {
                    // The local name is the name the hook is imported as in the file, and the imported name is the original name of the hook.
                    output.dataDependencies.importedHooks[`${specifier.local.name}`] =
                        specifier.imported.name;
                }
                else if (
                // We also have to track namespace level imports
                specifier.type === 'ImportNamespaceSpecifier') {
                    // If the specifier is a namespace import, we will track all hooks that are imported from that namespace.
                    PARSED_HOOKS.forEach((hook) => {
                        output.dataDependencies.importedHooks[`${specifier.local.name}.${hook}`] = hook;
                    });
                }
            });
            // Check for calls to our hooks.
        }
        else if (node.type === 'CallExpression') {
            let hookName = '';
            // This handles the case where the hook is called directly, eg `useCrmProperties()` (also supports aliased hooks)
            if (node.callee.type === 'Identifier' &&
                output.dataDependencies.importedHooks[node.callee.name]) {
                hookName = output.dataDependencies.importedHooks[node.callee.name];
            }
            else if (
            // This handles namespace import usage, eg `uiExtensions.useCrmProperties()`
            node.callee.type === 'MemberExpression' &&
                node.callee.object.type === 'Identifier' &&
                node.callee.property.type === 'Identifier' &&
                output.dataDependencies.importedHooks[`${node.callee.object.name}.${node.callee.property.name}`]) {
                hookName =
                    output.dataDependencies.importedHooks[`${node.callee.object.name}.${node.callee.property.name}`];
            }
            // Then we handle each hook individually, as the usages and tracking format are different.
            if (hookName === 'useCrmProperties') {
                _processCrmPropertiesHook(node, output);
            }
            else if (hookName === 'useAssociations') {
                _processAssociationsHook(node, output);
            }
        }
    }
    catch (e) {
        logger.warn(`Error collecting data dependencies (skipping): ${e instanceof Error ? e.message : String(e)}`);
    }
}
// Traverses an ESTree as defined by the EsTree spec https://github.com/estree/estree
// Uses the checks array to search the source code for matches
export function traverseAbstractSyntaxTree(ast, checks, extensionPath, logger) {
    const state = {
        functions: {},
        badImports: [],
        dataDependencies: {
            importedHooks: {},
            dependencies: [],
        },
        variableDeclarations: new Map(),
    };
    try {
        traverse(ast, {
            enter(node, parent) {
                try {
                    checks.forEach((check) => {
                        _checkForFunctionMetadata(node, parent, state, check.functionName);
                    });
                    checkForOutOfBoundsImageImports(node, state, extensionPath);
                    _collectVariableDeclarations(node, state);
                    _collectDataDependencies(node, state, logger);
                }
                catch (e) {
                    // Don't let individual node processing errors crash the entire traverse.
                    logger.warn(`Error processing node: ${JSON.stringify(node)}: ${e instanceof Error ? e.message : String(e)}`);
                }
            },
        });
    }
    catch (e) {
        logger.warn(`Unable to traverse AST: ${e instanceof Error ? e.message : String(e)}`);
    }
    return state;
}
