"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AjvErrorKeyword = exports.TranslationError = void 0;
exports.isTranslationError = isTranslationError;
exports.compileError = compileError;
exports.extractDotNotationValueFromTransformation = extractDotNotationValueFromTransformation;
const copy_1 = require("../lang/copy");
const path_1 = __importDefault(require("path"));
const logger_1 = require("@hubspot/local-dev-lib/logger");
function isTranslationError(error) {
    return error instanceof TranslationError;
}
function compileError(validatedTransformation) {
    const { fileParseResult } = validatedTransformation;
    const { errors } = fileParseResult;
    return {
        errors,
    };
}
class TranslationError extends Error {
    errors = [];
    translationContext;
    constructor(message, transformations, errors, translationContext) {
        super(message);
        this.name = 'TranslationError';
        this.translationContext = translationContext;
        this.errors = transformations.map((transformation, index) => compileTranslationErrors(transformation, errors[index]));
    }
    // Returns a formatted string for all the errors in all the files
    toString() {
        const listOfErrors = this.errors.map(({ file, errors }) => {
            if (errors.length === 0) {
                return null;
            }
            const projectRoot = path_1.default.dirname(path_1.default.dirname(this.translationContext.projectSourceDir));
            const relativePath = path_1.default.relative(projectRoot, path_1.default.join(this.translationContext.projectSourceDir, file));
            return copy_1.errorMessages.validation.errorWithFileHeader(relativePath, errors);
        });
        return `${this.message}:${listOfErrors
            .filter(error => error !== null)
            .join('')}`;
    }
}
exports.TranslationError = TranslationError;
function generateDotNotationPath(error) {
    const { instancePath } = error;
    const errorPath = instancePath
        .replace(/\/nodes\//, '')
        .split('/')
        .filter(subPath => subPath !== '')
        .join('.');
    if (errorPath === '') {
        // This is a top level error
        return `config`;
    }
    return `config.${errorPath}`;
}
function compileTranslationErrors(transformation, schemaErrors) {
    const hasOneOfErrors = schemaErrors?.some(error => isOneOfError(error));
    const { errors: existingErrors, file } = transformation.fileParseResult;
    const errors = [...existingErrors];
    // If there is a one of error, we need to preprocess the errors to group them by instancePath and keyword
    // This allows us to group data from the errors that correspond to the same field
    if (hasOneOfErrors) {
        errors.push(...preprocessSpecialErrors(schemaErrors, transformation));
    }
    else {
        schemaErrors?.forEach(error => {
            errors.push(generateErrorMessage(error, transformation));
        });
    }
    return { file, errors };
}
function preprocessSpecialErrors(schemaErrors, transformation) {
    const errors = [];
    const preprocessedErrors = {};
    schemaErrors?.forEach(error => {
        // Filter out the oneOf errors, they are a secondary error caused by other errors
        // and don't add any additional actionable context to the user
        if (isOneOfError(error)) {
            return;
        }
        const errorKey = `${error.instancePath}::${error.keyword}`;
        if (preprocessedErrors[errorKey]) {
            preprocessedErrors[errorKey].push(error);
        }
        else {
            preprocessedErrors[errorKey] = [error];
        }
    });
    Object.values(preprocessedErrors)?.forEach(value => {
        const newValue = value.reduce((cur, next) => {
            if (isEnumError(cur)) {
                return mergeEnumErrors(cur, next);
            }
            return cur;
        });
        errors.push(generateErrorMessage(newValue, transformation));
    });
    return errors;
}
function generateErrorMessage(error, transformation) {
    const errorPath = generateDotNotationPath(error);
    const errorMessage = copy_1.errorMessages.validation.errorWithField(errorPath, error.message);
    const params = Object.entries(error.params);
    if (params.length === 0) {
        return errorMessage;
    }
    const additionalContext = params
        .filter(([_, value]) => value)
        .map(([key, value]) => `${key}: ${Array.isArray(value) ? value.join(', ') : value}`);
    if (isRequiredError(error)) {
        return copy_1.errorMessages.validation.missingRequiredField(`${errorPath}.${error.params.missingProperty}`);
    }
    else if (isTypeError(error)) {
        const dotNotationPath = generateDotNotationPath(error);
        const value = extractDotNotationValueFromTransformation(dotNotationPath, transformation);
        return copy_1.errorMessages.validation.errorWithField(value !== undefined
            ? `Value (${value}) in ${dotNotationPath}`
            : dotNotationPath, error.message);
    }
    // Default case, it is not an error we know how to deal with
    return `${errorMessage} ${additionalContext.length > 0
        ? `\n\t\t-  ${additionalContext.join('\n\t\t- ')}`
        : ''}`;
}
function mergeEnumErrors(cur, next) {
    return {
        ...cur,
        // Overwrite the schema path so we know it's been modified
        schemaPath: 'CUSTOM',
        params: {
            ...cur.params,
            // Merge the allowed values from the enum errors
            allowedValues: [
                ...cur.params.allowedValues,
                ...next.params.allowedValues,
            ],
        },
    };
}
function extractDotNotationValueFromTransformation(dotNotation, transformation) {
    try {
        const parts = dotNotation.split('.');
        if (!transformation?.fileParseResult?.content || parts.length === 0) {
            return undefined;
        }
        let value = transformation.fileParseResult.content;
        // Traverse the nested objects and lists to get the end value
        parts.forEach(item => {
            // @ts-expect-error value is unknown since it is user generated config
            const newValue = value[item];
            if (newValue &&
                typeof newValue === 'object' &&
                !Array.isArray(newValue)) {
                value = Object.assign(Object.create(null), newValue);
            }
            else {
                value = newValue;
            }
        });
        // If the value is an object/array, stringify the value so it doesn't log as [object Object] or '' for array
        if (typeof value === 'object' && !!value) {
            return JSON.stringify(value);
        }
        return value;
    }
    catch (e) {
        logger_1.logger.debug('Unable to parse dot notation path to located value', e);
    }
}
function isOneOfError(error) {
    return error.keyword === exports.AjvErrorKeyword.OneOf;
}
function isRequiredError(error) {
    return error.keyword === exports.AjvErrorKeyword.Required;
}
function isEnumError(error) {
    return error.keyword === exports.AjvErrorKeyword.Enum;
}
function isTypeError(error) {
    return error.keyword === exports.AjvErrorKeyword.Type;
}
exports.AjvErrorKeyword = {
    AdditionalItems: 'additionalItems',
    AdditionalProperties: 'additionalProperties',
    Dependencies: 'dependencies',
    Enum: 'enum',
    ExclusiveMaximum: 'exclusiveMaximum',
    ExclusiveMinimum: 'exclusiveMinimum',
    Maximum: 'maximum',
    MaxItems: 'maxItems',
    MaxLength: 'maxLength',
    MaxProperties: 'maxProperties',
    Minimum: 'minimum',
    MinItems: 'minItems',
    MinLength: 'minLength',
    MinProperties: 'minProperties',
    MultipleOf: 'multipleOf',
    OneOf: 'oneOf',
    Pattern: 'pattern',
    Required: 'required',
    Type: 'type',
};
