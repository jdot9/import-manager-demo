"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLocalDevProjectNodes = getLocalDevProjectNodes;
exports.getRemovedNodesAndNodesWithErrors = getRemovedNodesAndNodesWithErrors;
exports.getLocalDevProfileData = getLocalDevProfileData;
const path_1 = __importDefault(require("path"));
const isDeepEqual_1 = require("@hubspot/local-dev-lib/isDeepEqual");
function getLocalDevProjectNodes(intermediateNodesIndexedByUid, projectSourceDir, projectNodesAtLastUpload) {
    const localDevProjectNodes = {};
    Object.entries(intermediateNodesIndexedByUid).forEach(([uid, node]) => {
        const component = intermediateNodesIndexedByUid[uid];
        const componentConfigPath = path_1.default.join(projectSourceDir, component.metaFilePath);
        let configUpdatedSinceLastUpload = false;
        if (projectNodesAtLastUpload) {
            const componentAtLastUpload = projectNodesAtLastUpload[uid];
            if (componentAtLastUpload) {
                configUpdatedSinceLastUpload = !(0, isDeepEqual_1.isDeepEqual)(component.config, componentAtLastUpload.config);
            }
            else {
                // Component is net new
                configUpdatedSinceLastUpload = true;
            }
        }
        localDevProjectNodes[uid] = {
            ...node,
            localDev: {
                componentRoot: path_1.default.dirname(componentConfigPath),
                componentConfigPath,
                configUpdatedSinceLastUpload,
                removed: false,
                parsingErrors: [],
            },
        };
    });
    return localDevProjectNodes;
}
function getRemovedNodesAndNodesWithErrors(intermediateNodesIndexedByUid, projectNodesAtLastUpload, parsingErrors) {
    const nodesWithErrors = {};
    Object.entries(projectNodesAtLastUpload).forEach(([uid, node]) => {
        // Node is still in the project
        if (intermediateNodesIndexedByUid[uid]) {
            return;
            // Node has parsing errors but was not removed
        }
        const errorForNode = parsingErrors.find(error => error.file === node.metaFilePath);
        if (errorForNode) {
            nodesWithErrors[uid] = {
                ...node,
                localDev: {
                    ...node.localDev,
                    parsingErrors: errorForNode.errors,
                },
            };
            //  Node was removed since the last upload
        }
        else {
            nodesWithErrors[uid] = {
                ...node,
                localDev: {
                    ...node.localDev,
                    removed: true,
                },
            };
        }
    });
    return nodesWithErrors;
}
function getLocalDevProfileData(profileVariables) {
    if (!profileVariables) {
        return {};
    }
    const localDevProfileData = {};
    Object.entries(profileVariables).forEach(([key, value]) => {
        localDevProfileData[key] = value.value;
    });
    return localDevProfileData;
}
