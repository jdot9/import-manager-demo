"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadHsProfileFile = loadHsProfileFile;
exports.getAllHsProfiles = getAllHsProfiles;
exports.loadHsMetaFiles = loadHsMetaFiles;
exports.locateHsMetaFiles = locateHsMetaFiles;
exports.projectContainsHsMetaFiles = projectContainsHsMetaFiles;
exports.convertPathToPosixPath = convertPathToPosixPath;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const fs_2 = require("@hubspot/local-dev-lib/fs");
const constants_1 = require("./constants");
const copy_1 = require("../lang/copy");
const logger_1 = require("@hubspot/local-dev-lib/logger");
const profiles_1 = require("./profiles");
function loadHsProfileFile(projectSourceDir, profile) {
    if (!profile) {
        throw new Error(copy_1.errorMessages.profile.noProfileSpecified);
    }
    const profileFile = (0, profiles_1.getHsProfileFilename)(profile);
    const profileFilepath = path_1.default.join(projectSourceDir, profileFile);
    let hsProfile;
    try {
        hsProfile = JSON.parse(fs_1.default.readFileSync(profileFilepath, 'utf8'));
    }
    catch (_e) {
        throw new Error(copy_1.errorMessages.profile.failedToLoadHsProfile(profileFile));
    }
    return hsProfile;
}
function getAllHsProfiles(projectSourceDir) {
    return new Promise((resolve, _reject) => {
        fs_1.default.readdir(projectSourceDir, { recursive: false, withFileTypes: true }, (err, files) => {
            if (err) {
                return resolve([]);
            }
            return resolve(files
                .filter(file => file.isFile() && (0, profiles_1.getIsProfileFile)(file.name))
                .map(file => (0, profiles_1.getHsProfileName)(file.name)));
        });
    });
}
async function loadHsMetaFiles(translationContext) {
    const metaFiles = await locateHsMetaFiles(translationContext.projectSourceDir);
    return parseHsMetaFiles(metaFiles, translationContext);
}
async function locateHsMetaFiles(projectSourceDir, options = { silent: false }) {
    return (await (0, fs_2.walk)(projectSourceDir, ['node_modules'])).reduce((metaFiles, file) => {
        if (!file.endsWith(constants_1.metafileExtension)) {
            return metaFiles;
        }
        const pathRelativeToProjectSrcDir = path_1.default.relative(projectSourceDir, file);
        const { dir: metaFileDir } = path_1.default.parse(pathRelativeToProjectSrcDir);
        const parentDirectory = metaFileDir.split(path_1.default.sep)[0];
        if (constants_1.allowedComponentDirectories.includes(metaFileDir)) {
            metaFiles.push({ file });
        }
        else if (constants_1.allowedSubComponentDirectories.includes(metaFileDir)) {
            metaFiles.push({ file, parentDirectory });
        }
        else {
            if (!options.silent) {
                logger_1.logger.warn(copy_1.logMessages.files.skippingPath(pathRelativeToProjectSrcDir));
            }
        }
        return metaFiles;
    }, []);
}
async function parseHsMetaFiles(metaFileLocations, translationContext) {
    const fileLoadResults = await Promise.all(metaFileLocations.map(fileLocation => {
        return loadFile(fileLocation, translationContext);
    }));
    return fileLoadResults.map(result => parseFile(result));
}
function loadFile(metaFileLocation, translationContext) {
    const { projectSourceDir } = translationContext;
    return new Promise(async (resolve) => {
        const { file, parentDirectory } = metaFileLocation;
        fs_1.default.readFile(file, 'utf-8', (err, content) => {
            if (err) {
                return resolve({
                    file,
                    errors: [err.message],
                });
            }
            resolve({
                file: path_1.default.relative(projectSourceDir, file),
                content,
                parentDirectory,
                errors: [],
            });
        });
    });
}
function parseFile(fileLoadResult) {
    if (!fileLoadResult.content) {
        // This is just to please TS, revisit this hack
        return { ...fileLoadResult, content: undefined };
    }
    let parsedFileContents;
    try {
        parsedFileContents = JSON.parse(fileLoadResult.content);
    }
    catch (_e) {
        fileLoadResult.errors?.push(copy_1.errorMessages.validation.invalidJson);
    }
    // Validate top-level fields (only uid, type, and config are expected)
    if (parsedFileContents &&
        typeof parsedFileContents === 'object' &&
        !Array.isArray(parsedFileContents)) {
        const actualFields = Object.keys(parsedFileContents);
        const unexpectedFields = actualFields.filter(field => !constants_1.allowedTopLevelFields.has(field));
        if (unexpectedFields.length > 0) {
            const unexpectedFieldsList = unexpectedFields.join(', ');
            fileLoadResult.errors?.push(copy_1.errorMessages.validation.unexpectedToplevelFields(unexpectedFieldsList));
        }
    }
    return { ...fileLoadResult, content: parsedFileContents };
}
async function projectContainsHsMetaFiles(projectSourceDir) {
    const hsMetaFiles = (await (0, fs_2.walk)(projectSourceDir, ['node_modules'])).filter(file => file.endsWith(constants_1.metafileExtension));
    return hsMetaFiles.length > 0;
}
function convertPathToPosixPath(filepath) {
    return filepath.replaceAll(path_1.default.win32.sep, path_1.default.posix.sep);
}
