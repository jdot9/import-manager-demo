"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapToInternalType = mapToInternalType;
exports.mapToUserFacingType = mapToUserFacingType;
exports.mapToUserFriendlyName = mapToUserFriendlyName;
exports.findTransformationByUid = findTransformationByUid;
exports.transform = transform;
exports.getIntermediateRepresentation = getIntermediateRepresentation;
exports.getParsingErrors = getParsingErrors;
exports.generateServerlessPackageComponent = generateServerlessPackageComponent;
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const logger_1 = require("@hubspot/local-dev-lib/logger");
const profiles_1 = require("./profiles");
const constants_1 = require("./constants");
const copy_1 = require("../lang/copy");
const utils_1 = require("./utils");
const files_1 = require("./files");
function calculateComponentDeps(fileValidationResult, parentComponents, appObjects, appFunctionsPackageUid) {
    let dependencies = {};
    // If there are dependencies in the config file, pass them through
    if (!fileValidationResult.content?.dependencies) {
        dependencies = { ...fileValidationResult.content?.dependencies };
    }
    const { type } = fileValidationResult.content;
    // If the component is a child of the App component, add the app and appObjects as dependencies
    if (constants_1.Components[type]?.parentComponent === constants_1.AppKey) {
        const parentUid = parentComponents[constants_1.AppKey];
        if (parentUid) {
            dependencies.app = parentUid;
        }
        else {
            logger_1.logger.debug(parentComponents);
            return {
                dependencies,
                errors: [copy_1.errorMessages.project.mustHaveAppComponent(type)],
            };
        }
        if (type !== constants_1.AppObjectKey) {
            dependencies.allAppObjects = appObjects;
        }
        if (type === constants_1.AppFunctionsKey && appFunctionsPackageUid) {
            dependencies.serverlessPackage = appFunctionsPackageUid;
        }
    }
    return { dependencies };
}
function mapToInternalType(type) {
    const resolvedType = constants_1.userFacingToInternalType[type] || type || '';
    return resolvedType.toUpperCase().replace(/-/g, '_');
}
function mapToUserFacingType(type) {
    return (constants_1.internalTypeToUserFacing[type] || type || '')
        .toLowerCase()
        .replace(/_/g, '-');
}
function mapToUserFriendlyName(internalType) {
    return constants_1.Components[mapToUserFacingType(internalType)]?.userFriendlyName || '';
}
function findTransformationByUid(transformations, uid) {
    return transformations.find(t => t.intermediateRepresentation?.uid === uid);
}
function transform(fileParseResults, translationContext, hsProfileContents) {
    const parentTypes = Object.keys(constants_1.ProjectStructure);
    const parentComponents = {};
    const allAppObjects = [];
    let appUid = '';
    let appFunctionsDirectory;
    // Apply the profile variable overrides to the config
    if (hsProfileContents) {
        fileParseResults = (0, profiles_1.applyHsProfileVariables)(fileParseResults, hsProfileContents);
    }
    // Compute the parent components, so we can add them as dependencies to the child components
    fileParseResults.forEach(file => {
        if (file.content?.type && parentTypes.includes(file.content.type)) {
            if (file.content.type === constants_1.AppKey) {
                appUid = file.content.uid;
            }
            parentComponents[file.content.type] = file.content.uid;
        }
        if (file.content?.type === constants_1.AppObjectKey) {
            allAppObjects.push(file.content.uid);
        }
        if (file.content?.type === constants_1.AppFunctionsKey) {
            appFunctionsDirectory = path_1.default.dirname(file.file);
        }
    });
    const autoGeneratedComponents = [];
    let serverlessPackageUid;
    if (appFunctionsDirectory) {
        const { uid, transformation } = generateServerlessPackageComponent(appFunctionsDirectory, translationContext, {
            app: appUid,
            allAppObjects,
        });
        serverlessPackageUid = uid;
        autoGeneratedComponents.push(transformation);
    }
    const transformations = fileParseResults.map((currentFile) => {
        if (!currentFile.content) {
            if (!currentFile.errors?.includes(copy_1.errorMessages.validation.invalidJson)) {
                currentFile.errors?.push(copy_1.errorMessages.project.fileContentMissingFor(currentFile.file));
            }
            return {
                intermediateRepresentation: null,
                fileParseResult: currentFile,
            };
        }
        const { config, uid, type } = currentFile.content;
        const { dependencies, errors } = calculateComponentDeps(currentFile, parentComponents, allAppObjects, serverlessPackageUid);
        if (errors) {
            currentFile.errors?.push(...errors);
        }
        return {
            intermediateRepresentation: {
                uid,
                config,
                componentType: mapToInternalType(type),
                componentDeps: dependencies,
                metaFilePath: (0, files_1.convertPathToPosixPath)(currentFile.file),
                files: {},
            },
            fileParseResult: currentFile,
        };
    });
    return [...autoGeneratedComponents, ...transformations];
}
function getIntermediateRepresentation(transformations, hsProfileContents, skipValidation) {
    const nodes = transformations.reduce((acc, current) => {
        if (!current.intermediateRepresentation) {
            return acc;
        }
        const { uid } = current.intermediateRepresentation;
        if (uid && acc[uid]) {
            const duplicates = transformations
                .filter(t => t.intermediateRepresentation?.uid === uid)
                .map(t => t.fileParseResult.file);
            throw new Error(copy_1.errorMessages.project.duplicateUid(uid, duplicates));
        }
        if (!skipValidation) {
            return {
                ...acc,
                // If the uid is not defined just make one up for the sake of indexing.
                // It will still fail validation, but this prevents collisions so we validate all files.
                [uid ||
                    `missing-${current.fileParseResult.file}`]: current.intermediateRepresentation,
            };
        }
        return {
            ...acc,
            [uid]: current.intermediateRepresentation,
        };
    }, {});
    const profileData = getProfileData(hsProfileContents);
    return {
        intermediateNodesIndexedByUid: nodes,
        profileData,
    };
}
function getParsingErrors(transformations) {
    return transformations
        .filter(t => t.fileParseResult.errors.length > 0)
        .map(t => t.fileParseResult);
}
function getProfileData(hsProfileContents) {
    const profileVariablesForBE = {};
    if (hsProfileContents && hsProfileContents.variables) {
        const profileVariables = (0, profiles_1.getHsProfileVariables)(hsProfileContents);
        Object.keys(profileVariables).forEach(key => {
            const profileVar = profileVariables[key];
            let variableTypeForBE;
            switch (typeof profileVar) {
                case 'string':
                    variableTypeForBE = constants_1.ProfileVariableTypes.PROFILE_STRING;
                    break;
                case 'number':
                    variableTypeForBE = (0, utils_1.getJavaNumberType)(profileVar);
                    break;
                case 'boolean':
                    variableTypeForBE = constants_1.ProfileVariableTypes.PROFILE_BOOLEAN;
                    break;
                default:
                    break;
            }
            if (variableTypeForBE) {
                profileVariablesForBE[key] = {
                    variableType: variableTypeForBE,
                    value: profileVar,
                };
            }
        });
    }
    return { vars: { profileVariables: profileVariablesForBE } };
}
function generateServerlessPackageComponent(appFunctionsDirectory, translationContext, componentDeps) {
    const appFunctionsPosix = (0, files_1.convertPathToPosixPath)(appFunctionsDirectory);
    const packageFilePosix = path_1.default.posix.join(appFunctionsPosix, constants_1.packageJson);
    const packageLockFilePosix = path_1.default.posix.join(appFunctionsPosix, constants_1.packageLockJson);
    const projectSourceDirPosix = (0, files_1.convertPathToPosixPath)(translationContext.projectSourceDir);
    const appFunctionsPackageFile = path_1.default.posix.join(projectSourceDirPosix, packageFilePosix);
    if (!fs_1.default.existsSync(appFunctionsPackageFile)) {
        throw new Error(copy_1.errorMessages.project.noPackageJsonForServerless(appFunctionsPackageFile));
    }
    const uid = `hubspot-serverless-package-uid`;
    return {
        uid,
        transformation: {
            fileParseResult: {
                file: '',
                errors: [],
            },
            intermediateRepresentation: {
                uid,
                componentType: mapToInternalType(constants_1.AppFunctionsPackageKey),
                config: {
                    packageFile: packageFilePosix,
                    packageLockfile: fs_1.default.existsSync(
                    // Don't use posix here because we are checking the file system
                    path_1.default.join(translationContext.projectSourceDir, path_1.default.join(appFunctionsDirectory, constants_1.packageLockJson)))
                        ? packageLockFilePosix
                        : undefined,
                },
                componentDeps,
                metaFilePath: packageFilePosix,
                files: {},
            },
        },
    };
}
