"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAjvInstance = createAjvInstance;
exports.validateIntermediateRepresentation = validateIntermediateRepresentation;
const schemas_1 = require("./schemas");
const _2020_1 = __importDefault(require("ajv/dist/2020"));
const errors_1 = require("./errors");
const copy_1 = require("../lang/copy");
const constants_1 = require("./constants");
const path_1 = __importDefault(require("path"));
const transform_1 = require("./transform");
const ajv_formats_1 = __importDefault(require("ajv-formats"));
const uid_1 = require("./uid");
function createAjvInstance() {
    const ajv = new _2020_1.default({ allErrors: true });
    (0, ajv_formats_1.default)(ajv);
    return ajv;
}
function validateIntermediateRepresentationNode(schema, transformation, irNode, translationContext) {
    if (constants_1.AutoGeneratedComponentTypes.includes((0, transform_1.mapToUserFacingType)(irNode.componentType))) {
        // Skip validation for auto-generated components
        return {
            valid: true,
        };
    }
    if (transformation.fileParseResult.errors.length > 0) {
        return {
            valid: false,
            errors: (0, errors_1.compileError)(transformation),
        };
    }
    const ajv = createAjvInstance();
    let shouldSkipValidation = false;
    if (!irNode.uid) {
        transformation.fileParseResult.errors.push(copy_1.errorMessages.validation.missingUid);
    }
    else {
        const uidValidationResult = (0, uid_1.validateUid)(irNode.uid);
        if (uidValidationResult) {
            transformation.fileParseResult.errors.push(uidValidationResult);
        }
    }
    if (!irNode.config) {
        transformation.fileParseResult.errors.push(copy_1.errorMessages.validation.missingConfig);
        // If there is no config block, there is nothing to validation
        shouldSkipValidation = true;
    }
    if (!schema[irNode.componentType]) {
        if (!irNode.componentType) {
            transformation.fileParseResult.errors.push(copy_1.errorMessages.validation.missingType);
        }
        else {
            transformation.fileParseResult.errors.push(copy_1.errorMessages.validation.unsupportedType(irNode.componentType));
        }
        // If there is no schema for the component type, there is no way to validate
        shouldSkipValidation = true;
    }
    const userFacingType = (0, transform_1.mapToUserFacingType)(irNode.componentType);
    const component = constants_1.Components[userFacingType];
    if (userFacingType && component) {
        const expectedParentDir = component.parentComponent
            ? constants_1.Components[component.parentComponent].dir
            : '';
        const expectedLocation = path_1.default.join(expectedParentDir, component.dir);
        const actualLocation = path_1.default.dirname(transformation.fileParseResult.file);
        if (expectedLocation !== actualLocation) {
            transformation.fileParseResult.errors.push(copy_1.errorMessages.validation.wrongDirectoryForComponent(actualLocation, userFacingType, component, path_1.default.join(translationContext.projectSourceDir, expectedLocation)));
        }
    }
    if (shouldSkipValidation) {
        return {
            valid: false,
            errors: (0, errors_1.compileError)(transformation),
        };
    }
    const validate = ajv.compile(schema[irNode.componentType]);
    const valid = validate(irNode.config);
    if (valid) {
        const { errors } = transformation.fileParseResult;
        // Even through it passed the schema validation, it may have had other errors along the way
        return errors.length === 0
            ? {
                valid: true,
            }
            : {
                valid: false,
                errors: (0, errors_1.compileError)(transformation),
            };
    }
    return {
        valid: false,
        schemaValidationErrors: validate.errors,
    };
}
async function validateIntermediateRepresentation(intermediateRepresentation, transformations, translationContext) {
    const hasAnyFileParseErrors = transformations.some(t => t.fileParseResult.errors.length > 0);
    const schema = await (0, schemas_1.getIntermediateRepresentationSchema)(translationContext);
    const potentialDuplicatesByComponent = {};
    const results = Object.values(intermediateRepresentation.intermediateNodesIndexedByUid).map(irNode => {
        const userFacingType = (0, transform_1.mapToUserFacingType)(irNode.componentType);
        const component = constants_1.Components[userFacingType];
        if (component && component.singularComponent) {
            potentialDuplicatesByComponent[userFacingType] = potentialDuplicatesByComponent[userFacingType]
                ? [...potentialDuplicatesByComponent[userFacingType], irNode]
                : [irNode];
        }
        const transformation = (0, transform_1.findTransformationByUid)(transformations, irNode.uid);
        if (!transformation) {
            return { valid: false, errors: [copy_1.errorMessages.validation.missingUid] };
        }
        return validateIntermediateRepresentationNode(schema, transformation, irNode, translationContext);
    });
    let hasDuplicates = false;
    Object.entries(potentialDuplicatesByComponent).forEach(([componentType, potentialDuplicates]) => {
        if (potentialDuplicates.length === 1) {
            return;
        }
        hasDuplicates = true;
        potentialDuplicates.forEach(duplicate => {
            const potentialDuplicateTransformation = (0, transform_1.findTransformationByUid)(transformations, duplicate.uid);
            if (potentialDuplicateTransformation) {
                potentialDuplicateTransformation.fileParseResult.errors.push(copy_1.errorMessages.project.duplicateComponent(componentType));
            }
        });
    });
    const valid = !hasAnyFileParseErrors &&
        !hasDuplicates &&
        results.every(result => result.valid);
    if (valid) {
        return {
            valid,
        };
    }
    const schemaValidationErrors = results.map(result => 'schemaValidationErrors' in result ? result.schemaValidationErrors : null);
    throw new errors_1.TranslationError(copy_1.errorMessages.project.failedToTranslateProject, transformations, schemaValidationErrors, translationContext);
}
