"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.migrate = migrate;
const fs_1 = require("@hubspot/local-dev-lib/fs");
const path_1 = __importDefault(require("path"));
const fs_2 = __importDefault(require("fs"));
const transform_1 = require("./transform");
const constants_1 = require("./constants");
const index_1 = require("../index");
const utils_1 = require("./utils");
const IR_FILENAME = 'ir.json';
const filesDirectory = 'files';
const OUTPUT_IR_FILE = 'FULL_IR.json';
async function migrate(inputDir, outputDir) {
    if (!fs_2.default.existsSync(inputDir)) {
        throw new Error(`Input directory ${inputDir} does not exist`);
    }
    const hsProjectJsonPath = path_1.default.join(inputDir, constants_1.hsProjectJsonFilename);
    if (!fs_2.default.existsSync(hsProjectJsonPath)) {
        throw new Error(`${constants_1.hsProjectJsonFilename} file does not exist in ${inputDir}`);
    }
    let hsProjectJson;
    try {
        hsProjectJson = (0, utils_1.loadJsonFile)(hsProjectJsonPath);
    }
    catch (e) {
        throw new Error(`Error parsing ${constants_1.hsProjectJsonFilename}: ${e}`);
    }
    const files = await (0, fs_1.walk)(inputDir);
    const sourceCodeOutputDir = path_1.default.join(outputDir, 'src');
    // Create the output directory if it doesn't exist
    ensureDirExists(sourceCodeOutputDir);
    files.forEach((filename) => {
        // Skip everything that's not an IR file
        if (!isIRFile(filename)) {
            return;
        }
        const irDirName = path_1.default.dirname(filename);
        const IR = (0, utils_1.loadJsonFile)(filename);
        const { metaFilePath } = IR;
        const projectConfig = convertIRToProjectConfig(IR);
        const fullOutputPath = path_1.default.join(sourceCodeOutputDir, getTargetDirectoryFromComponentType(projectConfig.type));
        // Ensure the output directory exists
        const currentFilesDirectory = path_1.default.join(irDirName, filesDirectory);
        ensureDirExists(currentFilesDirectory);
        fs_2.default.cpSync(currentFilesDirectory, fullOutputPath, {
            recursive: true,
        });
        // Use the metaFilePath if provided, otherwise use the project UID
        const hsmetaFilePath = path_1.default.join(fullOutputPath, metaFilePath
            ? path_1.default.basename(metaFilePath)
            : `${projectConfig.uid}${constants_1.metafileExtension}`);
        // Write the hsmeta file to the output directory
        fs_2.default.writeFileSync(hsmetaFilePath, JSON.stringify(projectConfig, null, 2));
    });
    const IR = await (0, index_1.translate)({
        projectSourceDir: sourceCodeOutputDir,
        platformVersion: hsProjectJson.platformVersion,
    }, { skipValidation: true });
    // Write the IR file to the output directory
    fs_2.default.writeFileSync(path_1.default.join(outputDir, OUTPUT_IR_FILE), JSON.stringify(IR, null, 2));
}
function ensureDirExists(dir) {
    if (!fs_2.default.existsSync(dir)) {
        fs_2.default.mkdirSync(dir, { recursive: true });
    }
}
function isIRFile(filename) {
    const { base } = path_1.default.parse(filename);
    return base.toLowerCase() === IR_FILENAME;
}
function convertIRToProjectConfig(IR) {
    const { config, uid, componentType } = IR;
    return {
        config,
        uid,
        type: (0, transform_1.mapToUserFacingType)(componentType),
        // We are assuming no dependencies for now since this will be a freshly migrated
        // project and the current supported components don't have non-hierarchical dependencies
        dependencies: undefined,
    };
}
function getTargetDirectoryFromComponentType(componentType) {
    const component = constants_1.Components[componentType];
    if (!component) {
        throw Error('Unsupported component type');
    }
    const parentDirectory = component.parentComponent
        ? constants_1.Components[component.parentComponent].dir
        : '';
    return path_1.default.join(parentDirectory, component.dir);
}
