"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.logMessages = exports.errorMessages = void 0;
exports.getInvalidJsonError = getInvalidJsonError;
exports.getMissingTypeError = getMissingTypeError;
exports.getMissingConfigError = getMissingConfigError;
exports.getMissingAccountIdError = getMissingAccountIdError;
exports.getMissingRequiredFieldError = getMissingRequiredFieldError;
exports.getFailedToFetchSchemasError = getFailedToFetchSchemasError;
exports.getUnsupportedTypeError = getUnsupportedTypeError;
const constants_1 = require("../lib/constants");
const transform_1 = require("../lib/transform");
exports.errorMessages = {
    api: {
        failedToFetchSchemas: 'Failed to fetch schemas',
        accountIdIsRequiredToFetchSchemas: 'Account id is required to fetch schemas',
    },
    project: {
        mustHaveAppComponent: (componentType) => `This '${componentType}' component must be a child of the '${constants_1.AppKey}' component. No *-hsmeta.json files were found with type '${constants_1.AppKey}'`,
        noHsMetaFiles: 'No *-hsmeta.json files found in the current directory. Please make sure you are inside the correct project directory.',
        failedToTranslateProject: 'Project validation failed',
        duplicateUid: (uid, files) => `Duplicate uid '${uid}' found in:\n- ${files.join('\n- ')}`,
        duplicateComponent: (componentType) => `Only one ${componentType} component is allowed`,
        noPackageJsonForServerless: (appFunctionsPackageFile) => `${appFunctionsPackageFile} does not exist. ${constants_1.Components[constants_1.AppFunctionsKey].userFriendlyName} requires a ${constants_1.packageJson} file to exist in this location`,
        fileContentMissingFor: (file) => `File content is missing for ${file}`,
    },
    profile: {
        noProfileSpecified: 'No profile specified',
        failedToLoadHsProfile: (profile) => `Failed to load profile ${profile}`,
        missingValue: (key, file) => `Missing value for ${key} in ${file}. Add ${key} to your profile variables.`,
        invalidValue: (key) => `Invalid value for ${key}. Value must be a string, number, or boolean.`,
    },
    validation: {
        errorWithFileHeader: (file, errors) => `\n\nEncountered the following errors for ${file}:\n\t- ${errors.join('\n\t- ')}`,
        missingRequiredField: (field) => `Missing required field: '${field}'`,
        missingUid: `Missing required field: 'uid'`,
        emptyUid: `'uid' must be at least one character long`,
        invalidUid: `'uid' should use only letters, numbers, periods, hyphens, and underscores (for example: app-id_1.2.3)`,
        uidTooLong: `'uid' must be 64 characters or less`,
        missingType: `Missing required field: 'type'`,
        missingConfig: `Missing required field: 'config'`,
        unsupportedType: (type) => `Unsupported type: ${(0, transform_1.mapToUserFacingType)(type)}`,
        errorWithField: (field, error) => `${field}: ${error || 'Unknown error'}`,
        invalidJson: 'Invalid JSON',
        unexpectedToplevelFields: (unexpectedFields) => `Unexpected top-level properties found: ${unexpectedFields}`,
        wrongDirectoryForComponent: (directory, componentType, componentMetadata, correctDir) => `The directory '${directory}' is incorrect for type '${componentType}'. ${componentMetadata.userFriendlyName} ${componentMetadata.userFriendlyTypePlural} should only be placed in the '${correctDir}' directory`,
    },
    migrateThemes: {
        rootReactThemeNotSupported: 'Migrating themes that live at the root of the project src directory is not supported. Please move the theme to a subdirectory.',
    },
};
function getInvalidJsonError() {
    return exports.errorMessages.validation.invalidJson;
}
function getMissingTypeError() {
    return exports.errorMessages.validation.missingType;
}
function getMissingConfigError() {
    return exports.errorMessages.validation.missingConfig;
}
function getMissingAccountIdError() {
    return exports.errorMessages.api.accountIdIsRequiredToFetchSchemas;
}
function getMissingRequiredFieldError(field) {
    return exports.errorMessages.validation.missingRequiredField(field);
}
function getFailedToFetchSchemasError() {
    return exports.errorMessages.api.failedToFetchSchemas;
}
function getUnsupportedTypeError(type) {
    return exports.errorMessages.validation.unsupportedType(type);
}
exports.logMessages = {
    files: {
        skippingPath: (path) => `Skipping ${path} as it is not in a valid directory`,
    },
};
