import { confirm, Separator as _Separator, select, input, checkbox, password, number, } from '@inquirer/prompts';
import { EXIT_CODES } from '../enums/exitCodes.js';
import chalk from 'chalk';
import { lib } from '../../lang/en.js';
import { uiLogger } from '../ui/logger.js';
export const Separator = new _Separator();
export const PROMPT_THEME = { prefix: { idle: chalk.green('?') } };
export const CHECKBOX_PROMPT_THEME = {
    prefix: { idle: chalk.green('?') },
    style: {
        disabledChoice: (text) => chalk.dim(` â—¯ ${text}`),
    },
};
function isUserCancellationError(error) {
    return error instanceof Error && error.name === 'ExitPromptError';
}
function isNoSelectableChoicesError(error) {
    return (error instanceof Error && error.message?.includes('No selectable choices'));
}
function handlePromptError(config, error) {
    if (isUserCancellationError(error)) {
        process.exit(EXIT_CODES.SUCCESS);
    }
    if (isNoSelectableChoicesError(error)) {
        if (!Array.isArray(config)) {
            uiLogger.log(config.message);
        }
        uiLogger.error(lib.prompts.promptUtils.errors.noSelectableChoices);
        process.exit(EXIT_CODES.ERROR);
    }
    throw error;
}
function mapPromptChoicesToChoices(choices) {
    return (choices?.map(choice => {
        if (typeof choice === 'string') {
            return { value: choice, name: choice };
        }
        else if (choice instanceof _Separator) {
            return choice;
        }
        return {
            value: choice.value,
            name: choice.name,
            disabled: choice.disabled,
            checked: choice.checked,
        };
    }) || []);
}
async function handleArrayConfig(config) {
    const result = {};
    for (const prompt of config) {
        if (prompt.when !== undefined) {
            const shouldPrompt = typeof prompt.when === 'function'
                ? prompt.when()
                : (prompt.when ?? true);
            if (!shouldPrompt) {
                continue;
            }
        }
        if (typeof prompt.message === 'function') {
            prompt.message = prompt.message(result);
        }
        // Pass the accumulated results to each prompt
        const promptWithAnswers = {
            ...prompt,
            default: typeof prompt.default === 'function'
                ? (answers) => {
                    const mergedAnswers = { ...answers, ...result };
                    return prompt.default(mergedAnswers);
                }
                : prompt.default,
        };
        const response = await promptUser(promptWithAnswers);
        Object.assign(result, response);
    }
    return result;
}
export async function promptUser(config) {
    try {
        if (Array.isArray(config)) {
            return await handleArrayConfig(config);
        }
        else {
            if (config.when !== undefined) {
                const shouldPrompt = typeof config.when === 'function'
                    ? config.when()
                    : (config.when ?? true);
                if (!shouldPrompt) {
                    return Promise.resolve({});
                }
            }
        }
        switch (config.type) {
            case 'list':
                return await handleSelectPrompt(config);
            case 'input':
                return await handleInputPrompt(config);
            case 'confirm':
                return await handleConfirmPrompt(config);
            case 'checkbox':
                return await handleCheckboxPrompt(config);
            case 'password':
                return await handlePasswordPrompt(config);
            case 'number':
                return await handleNumberPrompt(config);
            case 'rawlist':
                return await handleRawListPrompt(config);
            default:
                return await handleInputPrompt(config);
        }
    }
    catch (error) {
        handlePromptError(config, error);
    }
}
function handleRawListPrompt(config) {
    const choices = mapPromptChoicesToChoices(config.choices);
    choices.map((choice, index) => {
        if (!(choice instanceof _Separator)) {
            choice.name = `${index + 1}) ${choice.name}`;
        }
    });
    return select({
        message: config.message,
        choices: choices,
        pageSize: config.pageSize,
        default: config.default,
        loop: config.loop,
        theme: PROMPT_THEME,
    }).then(resp => ({ [config.name]: resp }));
}
function handleNumberPrompt(config) {
    return number({
        message: config.message,
        default: config.default,
        validate: config.validate,
        theme: PROMPT_THEME,
    }).then(resp => ({ [config.name]: resp }));
}
function handlePasswordPrompt(config) {
    return password({
        message: config.message,
        mask: '*',
        validate: config.validate,
        theme: PROMPT_THEME,
    }).then(resp => ({ [config.name]: resp }));
}
function handleCheckboxPrompt(config) {
    const choices = mapPromptChoicesToChoices(config.choices);
    return checkbox({
        message: config.message,
        choices: choices,
        pageSize: config.pageSize,
        validate: config.validate,
        loop: config.loop,
        theme: CHECKBOX_PROMPT_THEME,
        shortcuts: {
            invert: null,
        },
    }).then(resp => ({ [config.name]: resp }));
}
function handleConfirmPrompt(config) {
    return confirm({
        message: config.message,
        default: config.default,
        theme: PROMPT_THEME,
    }).then(resp => ({ [config.name]: resp }));
}
function handleInputPrompt(config) {
    return input({
        message: config.message,
        default: config.default,
        validate: config.validate,
        transformer: config.transformer,
        theme: PROMPT_THEME,
    }).then(resp => ({ [config.name]: resp }));
}
function handleSelectPrompt(config) {
    const choices = mapPromptChoicesToChoices(config.choices);
    return select({
        message: config.message,
        choices: choices,
        default: config.default,
        pageSize: config.pageSize,
        loop: config.loop,
        theme: PROMPT_THEME,
    }).then(resp => ({ [config.name]: resp }));
}
export async function confirmPrompt(message, options = {}) {
    const { defaultAnswer = true } = options;
    const { confirm: result } = await promptUser({
        name: 'confirm',
        type: 'confirm',
        message,
        default: defaultAnswer,
    });
    return result;
}
export async function listPrompt(message, { choices, when, defaultAnswer, validate, loop, }) {
    const { choice } = await promptUser({
        name: 'choice',
        type: 'list',
        message,
        choices,
        when,
        default: defaultAnswer,
        validate,
        loop,
    });
    return choice;
}
export async function inputPrompt(message, { when, validate, defaultAnswer, } = {}) {
    const { input } = await promptUser({
        name: 'input',
        type: 'input',
        default: defaultAnswer,
        message,
        when,
        validate,
    });
    return input;
}
