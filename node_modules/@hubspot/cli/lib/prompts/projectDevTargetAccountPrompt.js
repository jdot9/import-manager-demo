import { getSandboxUsageLimits } from '@hubspot/local-dev-lib/api/sandboxHubs';
import { HUBSPOT_ACCOUNT_TYPES, HUBSPOT_ACCOUNT_TYPE_STRINGS, } from '@hubspot/local-dev-lib/constants/config';
import { fetchDeveloperTestAccounts } from '@hubspot/local-dev-lib/api/developerTestAccounts';
import { promptUser } from './promptUtils.js';
import { lib } from '../../lang/en.js';
import { uiLogger } from '../ui/logger.js';
import { uiAccountDescription } from '../ui/index.js';
import { isSandbox } from '../accountTypes.js';
import { EXIT_CODES } from '../enums/exitCodes.js';
function mapNestedAccount(accountConfig) {
    const parentAccountId = accountConfig.parentAccountId ?? null;
    return {
        name: uiAccountDescription(accountConfig.accountId, false),
        value: {
            targetAccountId: accountConfig.accountId,
            createNestedAccount: false,
            parentAccountId,
        },
    };
}
function getNonConfigDeveloperTestAccountName(account) {
    return `${account.accountName} [${HUBSPOT_ACCOUNT_TYPE_STRINGS[HUBSPOT_ACCOUNT_TYPES.DEVELOPER_TEST]}] (${account.id})`;
}
export async function selectSandboxTargetAccountPrompt(accounts, defaultAccountConfig) {
    const defaultAccountId = defaultAccountConfig.accountId;
    let choices = [];
    let sandboxUsage = {
        STANDARD: { used: 0, available: 0, limit: 0 },
        DEVELOPER: { used: 0, available: 0, limit: 0 },
    };
    try {
        if (defaultAccountId) {
            const { data } = await getSandboxUsageLimits(defaultAccountId);
            sandboxUsage = data.usage;
        }
        else {
            uiLogger.error(lib.prompts.projectDevTargetAccountPrompt.noAccountId);
            process.exit(EXIT_CODES.ERROR);
        }
    }
    catch (err) {
        uiLogger.debug('Unable to fetch sandbox usage limits: ', err);
    }
    const sandboxAccounts = accounts
        .reverse()
        .filter(config => isSandbox(config) && config.parentAccountId === defaultAccountId);
    let disabledMessage = false;
    if (sandboxUsage['DEVELOPER'] && sandboxUsage['DEVELOPER'].available === 0) {
        if (sandboxAccounts.length < sandboxUsage['DEVELOPER'].limit) {
            disabledMessage =
                lib.prompts.projectDevTargetAccountPrompt.sandboxLimitWithSuggestion(sandboxUsage['DEVELOPER'].limit);
        }
        else {
            disabledMessage = lib.prompts.projectDevTargetAccountPrompt.sandboxLimit(sandboxUsage['DEVELOPER'].limit);
        }
    }
    // Order choices by Developer Sandbox -> Standard Sandbox
    choices = [
        ...sandboxAccounts
            .filter(a => a.accountType === HUBSPOT_ACCOUNT_TYPES.DEVELOPMENT_SANDBOX)
            .map(mapNestedAccount),
        ...sandboxAccounts
            .filter(a => a.accountType === HUBSPOT_ACCOUNT_TYPES.STANDARD_SANDBOX)
            .map(mapNestedAccount),
        {
            name: lib.prompts.projectDevTargetAccountPrompt.createNewSandboxOption,
            value: {
                targetAccountId: null,
                createNestedAccount: true,
            },
            disabled: disabledMessage,
        },
        {
            name: lib.prompts.projectDevTargetAccountPrompt
                .chooseDefaultAccountOption,
            value: {
                targetAccountId: defaultAccountId,
                createNestedAccount: false,
            },
        },
    ];
    return selectTargetAccountPrompt(defaultAccountId, 'sandbox account', choices);
}
export async function selectDeveloperTestTargetAccountPrompt(accounts, defaultAccountConfig) {
    const defaultAccountId = defaultAccountConfig.accountId;
    let devTestAccountsResponse;
    try {
        if (defaultAccountId) {
            const { data } = await fetchDeveloperTestAccounts(defaultAccountId);
            devTestAccountsResponse = data;
        }
        else {
            uiLogger.error(lib.prompts.projectDevTargetAccountPrompt.noAccountId);
            process.exit(EXIT_CODES.ERROR);
        }
    }
    catch (err) {
        uiLogger.debug('Unable to fetch developer test account usage limits: ', err);
    }
    let disabledMessage = false;
    if (devTestAccountsResponse &&
        devTestAccountsResponse.results.length >=
            devTestAccountsResponse.maxTestPortals) {
        disabledMessage =
            lib.prompts.projectDevTargetAccountPrompt.developerTestAccountLimit(devTestAccountsResponse.maxTestPortals);
    }
    const devTestAccounts = [];
    if (devTestAccountsResponse && devTestAccountsResponse.results) {
        const accountIds = accounts.map(account => account.accountId);
        devTestAccountsResponse.results.forEach(acct => {
            const inConfig = accountIds.includes(acct.id);
            devTestAccounts.push({
                name: getNonConfigDeveloperTestAccountName(acct),
                value: {
                    targetAccountId: acct.id,
                    createNestedAccount: false,
                    parentAccountId: defaultAccountId ?? null,
                    notInConfigAccount: inConfig ? null : acct,
                },
            });
        });
    }
    const choices = [
        ...devTestAccounts,
        {
            name: lib.prompts.projectDevTargetAccountPrompt
                .createNewDeveloperTestAccountOption,
            value: {
                targetAccountId: null,
                createNestedAccount: true,
            },
            disabled: disabledMessage,
        },
    ];
    return selectTargetAccountPrompt(defaultAccountId, HUBSPOT_ACCOUNT_TYPE_STRINGS[HUBSPOT_ACCOUNT_TYPES.DEVELOPER_TEST], choices);
}
async function selectTargetAccountPrompt(defaultAccountId, accountType, choices) {
    const accountId = defaultAccountId;
    const { targetAccountInfo } = await promptUser([
        {
            name: 'targetAccountInfo',
            type: 'list',
            message: lib.prompts.projectDevTargetAccountPrompt.promptMessage(accountType, uiAccountDescription(accountId)),
            choices,
            loop: false,
        },
    ]);
    return targetAccountInfo;
}
export async function confirmDefaultAccountPrompt(accountName, accountType) {
    const { useDefaultAccount } = await promptUser([
        {
            name: 'useDefaultAccount',
            type: 'confirm',
            message: lib.prompts.projectDevTargetAccountPrompt.confirmDefaultAccount(accountName, accountType),
        },
    ]);
    return useDefaultAccount;
}
export async function confirmUseExistingDeveloperTestAccountPrompt(account) {
    const { confirmUseExistingDeveloperTestAccount } = await promptUser([
        {
            name: 'confirmUseExistingDeveloperTestAccount',
            type: 'confirm',
            message: lib.prompts.projectDevTargetAccountPrompt.confirmUseExistingDeveloperTestAccount(getNonConfigDeveloperTestAccountName(account)),
        },
    ]);
    return confirmUseExistingDeveloperTestAccount;
}
