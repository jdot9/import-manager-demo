import { promptUser } from './promptUtils.js';
import { lib } from '../../lang/en.js';
const FUNCTIONS_FOLDER_PROMPT = {
    name: 'functionsFolder',
    message: lib.prompts.createFunctionPrompt.enterFolder,
    validate(val) {
        if (typeof val !== 'string') {
            return lib.prompts.createFunctionPrompt.errors.invalid;
        }
        else if (!val.length) {
            return lib.prompts.createFunctionPrompt.errors.blank;
        }
        else if (val.indexOf(' ') >= 0) {
            return lib.prompts.createFunctionPrompt.errors.space;
        }
        return true;
    },
};
const FUNCTION_FILENAME_PROMPT = {
    name: 'filename',
    message: lib.prompts.createFunctionPrompt.enterFilename,
    validate(val) {
        if (typeof val !== 'string') {
            return lib.prompts.createFunctionPrompt.errors.invalid;
        }
        else if (!val.length) {
            return lib.prompts.createFunctionPrompt.errors.blank;
        }
        else if (val.indexOf(' ') >= 0) {
            return lib.prompts.createFunctionPrompt.errors.space;
        }
        return true;
    },
};
const ENDPOINT_METHOD_PROMPT = {
    type: 'list',
    name: 'endpointMethod',
    message: lib.prompts.createFunctionPrompt.selectEndpointMethod,
    default: 'GET',
    choices: ['DELETE', 'GET', 'PATCH', 'POST', 'PUT'],
};
const ENDPOINT_PATH_PROMPT = {
    name: 'endpointPath',
    message: lib.prompts.createFunctionPrompt.enterEndpointPath,
    validate(val) {
        if (typeof val !== 'string') {
            return lib.prompts.createFunctionPrompt.errors.invalid;
        }
        else if (!val.length) {
            return lib.prompts.createFunctionPrompt.errors.blank;
        }
        else if (val.indexOf(' ') >= 0) {
            return lib.prompts.createFunctionPrompt.errors.space;
        }
        return true;
    },
};
export function createFunctionPrompt(commandArgs = {}) {
    // Check if all required parameters are provided (endpointMethod has default)
    const hasAllRequired = commandArgs.functionsFolder &&
        commandArgs.filename &&
        commandArgs.endpointPath;
    if (hasAllRequired) {
        return Promise.resolve({
            functionsFolder: commandArgs.functionsFolder,
            filename: commandArgs.filename,
            endpointMethod: commandArgs.endpointMethod || 'GET',
            endpointPath: commandArgs.endpointPath,
        });
    }
    const prompts = [];
    // Only prompt for missing parameters
    if (!commandArgs.functionsFolder) {
        prompts.push(FUNCTIONS_FOLDER_PROMPT);
    }
    if (!commandArgs.filename) {
        prompts.push(FUNCTION_FILENAME_PROMPT);
    }
    if (!commandArgs.endpointMethod) {
        prompts.push(ENDPOINT_METHOD_PROMPT);
    }
    if (!commandArgs.endpointPath) {
        prompts.push(ENDPOINT_PATH_PROMPT);
    }
    return promptUser(prompts).then(promptResponse => {
        // Merge prompted values with provided commandArgs
        return {
            functionsFolder: commandArgs.functionsFolder || promptResponse.functionsFolder,
            filename: commandArgs.filename || promptResponse.filename,
            endpointMethod: commandArgs.endpointMethod || promptResponse.endpointMethod || 'GET',
            endpointPath: commandArgs.endpointPath || promptResponse.endpointPath,
        };
    });
}
