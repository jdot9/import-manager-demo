import moment from 'moment';
import chalk from 'chalk';
import { Styles } from '@hubspot/local-dev-lib/logger';
import { uiLogger } from './logger.js';
import { lib } from '../../lang/en.js';
const SEPARATOR = ' - ';
const LOG_STATUS_COLORS = {
    SUCCESS: Styles.success,
    ERROR: Styles.error,
    UNHANDLED_ERROR: Styles.error,
    HANDLED_ERROR: Styles.error,
};
function errorHandler(log, options) {
    return `${formatLogHeader(log, options)}${formatError(log, options)}`;
}
const logHandler = {
    ERROR: errorHandler,
    UNHANDLED_ERROR: errorHandler,
    HANDLED_ERROR: errorHandler,
    SUCCESS: (log, options) => {
        return `${formatLogHeader(log, options)}${formatSuccess(log, options)}`;
    },
};
function formatSuccess(log, options) {
    if (!log.log || options.compact) {
        return '';
    }
    return `\n${log.log}`;
}
function formatError(log, options) {
    if (!log.error || options.compact) {
        return '';
    }
    return `${log.error.type}: ${log.error.message}\n${formatStackTrace(log)}`;
}
function formatLogHeader(log, options) {
    const color = LOG_STATUS_COLORS[log.status];
    const headerInsertion = options && options.insertions && options.insertions.header;
    return `${formatTimestamp(log)}${SEPARATOR}${color(log.status)}${headerInsertion ? `${SEPARATOR}${headerInsertion}` : ''}${SEPARATOR}${formatExecutionTime(log)}`;
}
function formatStackTrace(log) {
    const stackTrace = log.error?.stackTrace || [];
    return stackTrace
        .map(trace => {
        return `  at ${trace}\n`;
    })
        .join('');
}
function formatTimestamp(log) {
    return `${chalk.whiteBright(moment(log.createdAt).toISOString())}`;
}
function formatExecutionTime(log) {
    return `${chalk.whiteBright('Execution Time:')} ${log.executionTime}ms`;
}
function processLog(log, options) {
    try {
        return logHandler[log.status](log, options);
    }
    catch (e) {
        uiLogger.error(lib.ui.serverlessFunctionLogs.unableToProcessLog(JSON.stringify(log)));
    }
}
function isLogsResponse(logsResp) {
    return (logsResp &&
        'results' in logsResp &&
        Array.isArray(logsResp.results) &&
        logsResp.results !== undefined);
}
function processLogs(logsResp, options) {
    const isLogsResp = isLogsResponse(logsResp);
    if (!logsResp || (isLogsResp && logsResp.results.length === 0)) {
        return lib.ui.serverlessFunctionLogs.noLogsFound;
    }
    else if (isLogsResp) {
        return logsResp
            .results.map(log => {
            return processLog(log, options);
        })
            .join('\n');
    }
    return processLog(logsResp, options);
}
export function outputLogs(logsResp, options) {
    const result = processLogs(logsResp, options);
    if (result) {
        uiLogger.log(result);
    }
}
