import util from 'util';
import { vi } from 'vitest';
vi.mock('@hubspot/local-dev-lib/fs');
vi.mock('@hubspot/local-dev-lib/config');
vi.mock('@hubspot/local-dev-lib/config/defaultAccountOverride');
vi.mock('@hubspot/local-dev-lib/personalAccessKey');
vi.mock('../../projects/config');
vi.mock('@hubspot/local-dev-lib/api/projects');
vi.mock('util');
vi.mock('../../jsonLoader.js', () => {
    return {
        pkg: {
            name: '@hubspot/cli',
            version: '1.0.0',
        },
        loadJson: vi.fn(),
    };
});
import { DiagnosticInfoBuilder, } from '../DiagnosticInfoBuilder.js';
import { getConfigAccountIfExists as _getConfigAccountIfExists, getConfigAccountById as _getConfigAccountById, getConfigFilePath as _getConfigFilePath, isConfigFlagEnabled as _isConfigFlagEnabled, getConfigDefaultAccountIfExists as _getConfigDefaultAccountIfExists, } from '@hubspot/local-dev-lib/config';
import { getDefaultAccountOverrideFilePath as _getDefaultAccountOverrideFilePath } from '@hubspot/local-dev-lib/config/defaultAccountOverride';
import { getAccessToken as _getAccessToken } from '@hubspot/local-dev-lib/personalAccessKey';
import { walk as _walk } from '@hubspot/local-dev-lib/fs';
import { getProjectConfig as _getProjectConfig } from '../../projects/config.js';
import { fetchProject as _fetchProject } from '@hubspot/local-dev-lib/api/projects';
const walk = _walk;
const getAccessToken = _getAccessToken;
const getConfigAccountById = _getConfigAccountById;
const getConfigAccountIfExists = _getConfigAccountIfExists;
const getConfigDefaultAccountIfExists = _getConfigDefaultAccountIfExists;
const getConfigFilePath = _getConfigFilePath;
const getDefaultAccountOverrideFilePath = _getDefaultAccountOverrideFilePath;
const getProjectConfig = _getProjectConfig;
const isConfigFlagEnabled = _isConfigFlagEnabled;
const fetchProject = _fetchProject;
const mockPromisifyImpl = vi.fn();
const utilPromisify = vi.fn(() => mockPromisifyImpl);
util.promisify = utilPromisify;
describe('lib/doctor/DiagnosticInfo', () => {
    const accountId = 898989;
    const accountConfig = {
        name: 'test-account',
        accountId: accountId,
        env: 'prod',
        authType: 'personalaccesskey',
        accountType: 'STANDARD',
        personalAccessKey: 'super-secret-key',
    };
    const nodeVersion = 'v18.17.0';
    const processInfo = {
        platform: 'darwin',
        arch: 'x64',
        versions: { node: nodeVersion },
        mainModule: { path: '/path/to/main/module' },
    };
    const projectDir = '/Users/test/project';
    const projectFiles = [
        `${projectDir}/.gitignore`,
        `${projectDir}/README.md`,
        // Config files
        `${projectDir}/hsproject.json`,
        `${projectDir}/src/app/app.json`,
        `${projectDir}/src/app/public-app.json`,
        // Serverless files
        `${projectDir}/src/app/app.functions/.env`,
        `${projectDir}/src/app/app.functions/function.js`,
        `${projectDir}/src/app/app.functions/serverless.json`,
        `${projectDir}/src/app/app.functions/package.json`,
        `${projectDir}/src/app/app.functions/package-lock.json`,
        // Extension files
        `${projectDir}/src/app/extensions/extension.js`,
        `${projectDir}/src/app/extensions/extension.json`,
        `${projectDir}/src/app/extensions/package.json`,
        `${projectDir}/src/app/extension/package-lock.json`,
        `${projectDir}/src/app/app.functions/node_modules/axios`,
    ];
    const npmVersion = 'v8.17.0';
    const configPath = '/path/to/config';
    const defaultAccountOverrideFile = 'path/to/default/account/override/.hsaccount';
    beforeEach(() => {
        getConfigAccountIfExists.mockReturnValue({
            accountId,
            name: 'test',
        });
        getConfigAccountById.mockReturnValue(accountConfig);
        getConfigDefaultAccountIfExists.mockReturnValue(accountConfig);
        walk.mockResolvedValue(projectFiles);
        isConfigFlagEnabled.mockReturnValue(false);
        mockPromisifyImpl.mockResolvedValue(npmVersion);
    });
    it('should initialize the required state on creation', () => {
        const builder = new DiagnosticInfoBuilder(processInfo);
        expect(getConfigDefaultAccountIfExists).toHaveBeenCalledTimes(1);
        expect(builder.accountId).toEqual(accountId);
        expect(builder.env).toEqual(accountConfig.env);
        expect(builder.authType).toEqual(accountConfig.authType);
        expect(builder.accountType).toEqual(accountConfig.accountType);
        expect(builder.personalAccessKey).toEqual(accountConfig.personalAccessKey);
        expect(builder.processInfo).toEqual(processInfo);
    });
    describe('generateDiagnosticInfo', () => {
        let builder;
        let projectConfig;
        let projectDetails;
        let accessToken;
        beforeEach(() => {
            builder = new DiagnosticInfoBuilder(processInfo);
            projectConfig = {
                projectDir,
                projectConfig: {
                    name: 'My project',
                    srcDir: 'project-dir',
                    platformVersion: 'test',
                },
            };
            projectDetails = {
                createdAt: 12345,
                deletedAt: 0,
                deployedBuildId: 1,
                id: 8989898,
                isLocked: false,
                name: projectConfig.projectConfig.name,
                portalId: accountId,
                updatedAt: 12345,
            };
            accessToken = {
                accessToken: 'super-secret-dont-put-this-in-a-unit-test',
                accountType: 'STANDARD',
                encodedOAuthRefreshToken: '',
                expiresAt: '',
                hubName: projectConfig.projectConfig.name,
                portalId: accountId,
                scopeGroups: [],
                enabledFeatures: {},
            };
            getProjectConfig.mockResolvedValue(projectConfig);
            // @ts-expect-error - Mocking AxiosResponse
            fetchProject.mockResolvedValue({
                data: projectDetails,
            });
            getAccessToken.mockResolvedValue(accessToken);
            getConfigFilePath.mockReturnValue(configPath);
            getDefaultAccountOverrideFilePath.mockReturnValue(defaultAccountOverrideFile);
        });
        it('should gather the required data and generate the diagnostic', async () => {
            const diagnosticInfo = await builder.generateDiagnosticInfo();
            expect(getProjectConfig).toHaveBeenCalledTimes(1);
            expect(fetchProject).toHaveBeenCalledTimes(1);
            expect(fetchProject).toHaveBeenCalledWith(accountId, projectConfig.projectConfig.name);
            expect(getAccessToken).toHaveBeenCalledTimes(1);
            expect(getAccessToken).toHaveBeenCalledWith(accountConfig.personalAccessKey, accountConfig.env, accountId);
            // @ts-expect-error Accessing private field
            expect(builder._projectConfig).toEqual(projectConfig);
            expect(diagnosticInfo).toMatchSnapshot();
        });
        it('should handle errors when fetching project details', async () => {
            fetchProject.mockRejectedValue(new Error('Failed to fetch project details'));
            const diagnosticInfo = await builder.generateDiagnosticInfo();
            expect(fetchProject).toHaveBeenCalledTimes(1);
            expect(diagnosticInfo.project.details).toBeUndefined();
        });
        it('should handle errors when fetching access token', async () => {
            getAccessToken.mockRejectedValue(new Error('Failed to fetch access token'));
            const diagnosticInfo = await builder.generateDiagnosticInfo();
            expect(getAccessToken).toHaveBeenCalledTimes(1);
            expect(diagnosticInfo.account.name).toBeUndefined();
            expect(diagnosticInfo.account.scopeGroups).toBeUndefined();
            expect(diagnosticInfo.account.enabledFeatures).toBeUndefined();
        });
        it('should handle errors when fetching project filenames', async () => {
            walk.mockRejectedValue(new Error('Failed to walk project directory'));
            const diagnosticInfo = await builder.generateDiagnosticInfo();
            expect(walk).toHaveBeenCalledTimes(1);
            expect(diagnosticInfo.files).toEqual([]);
        });
    });
});
