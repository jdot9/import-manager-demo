import { getAccessToken, updateConfigWithAccessToken, } from '@hubspot/local-dev-lib/personalAccessKey';
import { getConfigAccountIfExists, updateConfigAccount, } from '@hubspot/local-dev-lib/config';
import { uiLogger } from './ui/logger.js';
import { createDeveloperTestAccount, fetchDeveloperTestAccountGateSyncStatus, generateDeveloperTestAccountPersonalAccessKey, } from '@hubspot/local-dev-lib/api/developerTestAccounts';
import { HUBSPOT_ACCOUNT_TYPES } from '@hubspot/local-dev-lib/constants/config';
import { createSandbox, createV2Sandbox, getSandboxPersonalAccessKey, } from '@hubspot/local-dev-lib/api/sandboxHubs';
import { personalAccessKeyPrompt } from './prompts/personalAccessKeyPrompt.js';
import { createDeveloperTestAccountConfigPrompt } from './prompts/createDeveloperTestAccountConfigPrompt.js';
import { cliAccountNamePrompt } from './prompts/accountNamePrompt.js';
import SpinniesManager from './ui/SpinniesManager.js';
import { debugError, logError } from './errorHandlers/index.js';
import { SANDBOX_API_TYPE_MAP, SANDBOX_TYPE_MAP_V2, handleSandboxCreateError, } from './sandboxes.js';
import { handleDeveloperTestAccountCreateError } from './developerTestAccounts.js';
import { lib } from '../lang/en.js';
import { poll } from './polling.js';
export async function saveAccountToConfig(accountId, accountName, env, personalAccessKey, force = false) {
    if (!personalAccessKey) {
        const configData = await personalAccessKeyPrompt({
            env,
            account: accountId,
        });
        personalAccessKey = configData.personalAccessKey;
    }
    const token = await getAccessToken(personalAccessKey, env);
    const updatedConfig = await updateConfigWithAccessToken(token, personalAccessKey, env);
    let validName = updatedConfig?.name || '';
    if (!updatedConfig?.name) {
        const nameForConfig = accountName.toLowerCase().split(' ').join('-');
        validName = nameForConfig;
        const existingAccount = getConfigAccountIfExists(nameForConfig);
        if (existingAccount) {
            if (!force) {
                uiLogger.log('');
                uiLogger.warn(lib.prompts.accountNamePrompt.errors.accountNameExists(nameForConfig));
                const { name: promptName } = await cliAccountNamePrompt(nameForConfig + `_${accountId}`);
                validName = promptName;
            }
            else {
                // Basic invalid name handling when force flag is passed
                validName = nameForConfig + `_${accountId}`;
            }
        }
    }
    updateConfigAccount({
        ...updatedConfig,
        name: validName,
    });
    uiLogger.log('');
    return validName;
}
export async function createDeveloperTestAccountV2(parentAccountId, testAccountConfig) {
    const result = {
        accountName: testAccountConfig.accountName,
    };
    const { data } = await createDeveloperTestAccount(parentAccountId, testAccountConfig);
    result.accountId = data.id;
    try {
        await poll(() => fetchDeveloperTestAccountGateSyncStatus(parentAccountId, result.accountId), {
            successStates: ['SUCCESS'],
            errorStates: [],
        });
    }
    catch (err) {
        debugError(err);
        throw new Error(lib.buildAccount.createDeveloperTestAccountV2.syncFailure);
    }
    // HACK: The status endpoint sometimes returns an early success status.
    // Sleep for an extra 5 seconds to make sure the sync is actually complete.
    await new Promise(resolve => setTimeout(resolve, 5000));
    try {
        // Attempt to generate a new personal access key for the test account now that gate sync is complete.
        const { data } = await generateDeveloperTestAccountPersonalAccessKey(parentAccountId, result.accountId);
        result.personalAccessKey = data.personalAccessKey;
    }
    catch (err) {
        debugError(err);
        throw new Error(lib.buildAccount.createDeveloperTestAccountV2.pakFailure);
    }
    return result;
}
export async function buildDeveloperTestAccount(testAccountName, parentAccountConfig, env, portalLimit, useV2 = false) {
    const parentAccountId = parentAccountConfig.accountId;
    let testAccountConfig = {
        accountName: testAccountName,
    };
    if (!parentAccountId) {
        throw new Error(lib.developerTestAccount.create.loading.fail(''));
    }
    if (useV2) {
        testAccountConfig = await createDeveloperTestAccountConfigPrompt({
            name: testAccountConfig.accountName,
            description: 'Test Account created by the HubSpot CLI',
        }, false);
    }
    SpinniesManager.init({
        succeedColor: 'white',
    });
    uiLogger.log('');
    SpinniesManager.add('buildDeveloperTestAccount', {
        text: lib.developerTestAccount.create.loading.add(testAccountName),
    });
    let developerTestAccountId;
    let developerTestAccountPersonalAccessKey;
    try {
        if (useV2) {
            const result = await createDeveloperTestAccountV2(parentAccountId, testAccountConfig);
            developerTestAccountId = result.accountId;
            developerTestAccountPersonalAccessKey = result.personalAccessKey;
        }
        else {
            const { data } = await createDeveloperTestAccount(parentAccountId, testAccountName);
            developerTestAccountId = data.id;
            developerTestAccountPersonalAccessKey = data.personalAccessKey;
        }
        SpinniesManager.succeed('buildDeveloperTestAccount', {
            text: lib.developerTestAccount.create.loading.succeed(testAccountName, developerTestAccountId.toString()),
        });
    }
    catch (e) {
        debugError(e);
        SpinniesManager.fail('buildDeveloperTestAccount', {
            text: lib.developerTestAccount.create.loading.fail(testAccountName),
        });
        handleDeveloperTestAccountCreateError(e, parentAccountId, env, portalLimit);
    }
    try {
        await saveAccountToConfig(developerTestAccountId, testAccountName, env, developerTestAccountPersonalAccessKey);
    }
    catch (err) {
        logError(err);
        throw err;
    }
    return developerTestAccountId;
}
export async function buildSandbox(sandboxName, parentAccountConfig, sandboxType, env, force = false) {
    const sandboxTypeKey = sandboxType === HUBSPOT_ACCOUNT_TYPES.STANDARD_SANDBOX
        ? 'standard'
        : 'developer';
    const parentAccountId = parentAccountConfig.accountId;
    if (!parentAccountId) {
        throw new Error(lib.sandbox.create[sandboxTypeKey].loading.fail(''));
    }
    SpinniesManager.init({
        succeedColor: 'white',
    });
    uiLogger.log('');
    SpinniesManager.add('buildSandbox', {
        text: lib.sandbox.create[sandboxTypeKey].loading.add(sandboxName),
    });
    let sandbox;
    try {
        const sandboxApiType = SANDBOX_API_TYPE_MAP[sandboxType];
        const { data } = await createSandbox(parentAccountId, sandboxName, sandboxApiType);
        sandbox = { name: sandboxName, ...data };
        SpinniesManager.succeed('buildSandbox', {
            text: lib.sandbox.create[sandboxTypeKey].loading.succeed(sandboxName, sandbox.sandbox.sandboxHubId.toString()),
        });
    }
    catch (e) {
        debugError(e);
        SpinniesManager.fail('buildSandbox', {
            text: lib.sandbox.create[sandboxTypeKey].loading.fail(sandboxName),
        });
        handleSandboxCreateError(e, env, sandboxName, parentAccountId);
    }
    try {
        await saveAccountToConfig(sandbox.sandbox.sandboxHubId, sandboxName, env, sandbox.personalAccessKey, force);
    }
    catch (err) {
        logError(err);
        throw err;
    }
    return sandbox;
}
export async function buildV2Sandbox(sandboxName, parentAccountConfig, sandboxType, syncObjectRecords, env, force = false) {
    const sandboxTypeKey = sandboxType === HUBSPOT_ACCOUNT_TYPES.STANDARD_SANDBOX
        ? 'standard'
        : 'developer';
    const parentAccountId = parentAccountConfig.accountId;
    if (!parentAccountId) {
        throw new Error(lib.sandbox.create[sandboxTypeKey].loading.fail(''));
    }
    SpinniesManager.init({
        succeedColor: 'white',
    });
    uiLogger.log('');
    SpinniesManager.add('buildV2Sandbox', {
        text: lib.sandbox.create[sandboxTypeKey].loading.add(sandboxName),
    });
    let sandbox;
    let pak;
    try {
        const sandboxTypeV2 = SANDBOX_TYPE_MAP_V2[sandboxType];
        const { data } = await createV2Sandbox(parentAccountId, sandboxName, sandboxTypeV2, syncObjectRecords);
        sandbox = { ...data };
        const { data: { personalAccessKey }, } = await getSandboxPersonalAccessKey(parentAccountId, sandbox.sandboxHubId);
        pak = personalAccessKey.encodedOAuthRefreshToken;
        SpinniesManager.succeed('buildV2Sandbox', {
            text: lib.sandbox.create[sandboxTypeKey].loading.succeed(sandboxName, sandbox.sandboxHubId.toString()),
        });
    }
    catch (e) {
        debugError(e);
        SpinniesManager.fail('buildV2Sandbox', {
            text: lib.sandbox.create[sandboxTypeKey].loading.fail(sandboxName),
        });
        handleSandboxCreateError(e, env, sandboxName, parentAccountId);
    }
    try {
        await saveAccountToConfig(sandbox.sandboxHubId, sandboxName, env, pak, force);
    }
    catch (err) {
        logError(err);
        throw err;
    }
    return { sandbox };
}
