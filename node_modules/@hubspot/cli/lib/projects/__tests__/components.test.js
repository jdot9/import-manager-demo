import fs from 'fs';
import { handleComponentCollision, updateHsMetaFilesWithAutoGeneratedFields, } from '../components.js';
import { uiLogger } from '../../ui/logger.js';
import { coerceToValidUid } from '@hubspot/project-parsing-lib';
import { fileExists } from '../../validation.js';
vi.mock('fs');
vi.mock('../../ui/logger.js');
vi.mock('../../validation.js');
vi.mock('@hubspot/project-parsing-lib', () => ({
    coerceToValidUid: vi.fn(),
    metafileExtension: '.module.meta.json',
}));
vi.mock('@hubspot/project-parsing-lib/src/lib/constants.js', () => ({
    AppKey: 'app',
}));
const mockedFs = vi.mocked(fs);
const mockCoerceToValidUid = vi.mocked(coerceToValidUid);
const mockedFileExists = vi.mocked(fileExists);
describe('lib/projects/components', () => {
    describe('handleComponentCollision()', () => {
        const mockCollision = {
            dest: '/dest/path',
            src: '/src/path',
            collisions: [],
        };
        beforeEach(() => {
            vi.resetAllMocks();
            // Default: fileExists returns false (file doesn't exist)
            mockedFileExists.mockReturnValue(false);
        });
        afterEach(() => {
            vi.restoreAllMocks();
        });
        it('handles source file collisions by renaming them with sequential numbers', () => {
            const collision = {
                ...mockCollision,
                collisions: ['component.js', 'utils.ts'],
            };
            mockedFs.copyFileSync.mockImplementation(() => { });
            handleComponentCollision(collision);
            expect(mockedFs.copyFileSync).toHaveBeenCalledTimes(2);
            expect(mockedFs.copyFileSync).toHaveBeenCalledWith('/src/path/component.js', '/dest/path/component-2.js');
            expect(mockedFs.copyFileSync).toHaveBeenCalledWith('/src/path/utils.ts', '/dest/path/utils-2.ts');
        });
        it('handles metafile collisions by renaming and updating references', () => {
            const collision = {
                ...mockCollision,
                collisions: ['component.module.meta.json', 'source.js'],
            };
            const mockMetaContent = JSON.stringify({
                file: 'source.js',
                label: 'Test Component',
            });
            mockedFs.readFileSync.mockReturnValue(mockMetaContent);
            mockedFs.writeFileSync.mockImplementation(() => { });
            mockedFs.copyFileSync.mockImplementation(() => { });
            // Mock metafileExtension
            Object.defineProperty(require('@hubspot/project-parsing-lib'), 'metafileExtension', {
                value: '.module.meta.json',
                writable: false,
            });
            handleComponentCollision(collision);
            expect(mockedFs.readFileSync).toHaveBeenCalledWith('/src/path/component.module.meta.json', 'utf-8');
            expect(mockedFs.writeFileSync).toHaveBeenCalledWith('/dest/path/component-2.module.meta.json', expect.stringContaining('source-2.js'));
            expect(mockedFs.copyFileSync).toHaveBeenCalledWith('/src/path/source.js', '/dest/path/source-2.js');
        });
        it('handles package.json collisions by merging dependencies', () => {
            const collision = {
                ...mockCollision,
                collisions: ['package.json'],
            };
            const existingPackageJson = {
                name: 'existing-package',
                dependencies: {
                    existing: '1.0.0',
                    shared: '1.0.0',
                },
                devDependencies: {
                    'existing-dev': '1.0.0',
                },
            };
            const newPackageJson = {
                name: 'new-package',
                dependencies: {
                    new: '2.0.0',
                    shared: '2.0.0',
                },
                devDependencies: {
                    'new-dev': '2.0.0',
                    'existing-dev': '2.0.0',
                },
            };
            mockedFs.readFileSync
                .mockReturnValueOnce(JSON.stringify(existingPackageJson))
                .mockReturnValueOnce(JSON.stringify(newPackageJson));
            mockedFs.writeFileSync.mockImplementation(() => { });
            // Mock console.log to avoid output during tests
            const consoleSpy = vi.spyOn(console, 'log').mockImplementation(() => { });
            handleComponentCollision(collision);
            const expectedMergedPackageJson = {
                name: 'existing-package',
                dependencies: {
                    new: '2.0.0',
                    shared: '1.0.0',
                    existing: '1.0.0',
                },
                devDependencies: {
                    'new-dev': '2.0.0',
                    'existing-dev': '1.0.0',
                },
            };
            expect(mockedFs.writeFileSync).toHaveBeenCalledWith('/dest/path/package.json', JSON.stringify(expectedMergedPackageJson, null, 2));
            consoleSpy.mockRestore();
        });
        it('handles mixed collision types (source files, metafiles, and package.json)', () => {
            const collision = {
                ...mockCollision,
                collisions: [
                    'component.js',
                    'component.module.meta.json',
                    'package.json',
                    'utils.ts',
                ],
            };
            const mockMetaContent = JSON.stringify({
                file: 'component.js',
                label: 'Test Component',
            });
            const existingPackageJson = { name: 'existing' };
            const newPackageJson = { name: 'new', dependencies: { test: '1.0.0' } };
            mockedFs.readFileSync
                .mockReturnValueOnce(mockMetaContent)
                .mockReturnValueOnce(JSON.stringify(existingPackageJson))
                .mockReturnValueOnce(JSON.stringify(newPackageJson));
            mockedFs.writeFileSync.mockImplementation(() => { });
            mockedFs.copyFileSync.mockImplementation(() => { });
            // Mock metafileExtension
            Object.defineProperty(require('@hubspot/project-parsing-lib'), 'metafileExtension', {
                value: '.module.meta.json',
                writable: false,
            });
            const consoleSpy = vi.spyOn(console, 'log').mockImplementation(() => { });
            handleComponentCollision(collision);
            // Verify source files are copied with new names
            expect(mockedFs.copyFileSync).toHaveBeenCalledWith('/src/path/component.js', '/dest/path/component-2.js');
            expect(mockedFs.copyFileSync).toHaveBeenCalledWith('/src/path/utils.ts', '/dest/path/utils-2.ts');
            // Verify metafile is updated and written with new name
            expect(mockedFs.writeFileSync).toHaveBeenCalledWith('/dest/path/component-2.module.meta.json', expect.stringContaining('component-2.js'));
            // Verify package.json is merged
            expect(mockedFs.writeFileSync).toHaveBeenCalledWith('/dest/path/package.json', expect.stringContaining('"dependencies"'));
            consoleSpy.mockRestore();
        });
        it('handles empty collisions array gracefully', () => {
            const collision = {
                ...mockCollision,
                collisions: [],
            };
            handleComponentCollision(collision);
            expect(mockedFs.copyFileSync).not.toHaveBeenCalled();
            expect(mockedFs.readFileSync).not.toHaveBeenCalled();
            expect(mockedFs.writeFileSync).not.toHaveBeenCalled();
        });
        it('correctly categorizes different file types', () => {
            const collision = {
                ...mockCollision,
                collisions: [
                    'regular.js',
                    'nested/path/file.ts',
                    'component.meta.json',
                    'another.meta.json',
                    'package.json',
                ],
            };
            // Mock metafileExtension
            Object.defineProperty(require('@hubspot/project-parsing-lib'), 'metafileExtension', {
                value: '.meta.json',
                writable: false,
            });
            const mockMetaContent = '{}';
            mockedFs.readFileSync.mockReturnValue(mockMetaContent);
            mockedFs.writeFileSync.mockImplementation(() => { });
            // Track what files are being copied to debug the issue
            mockedFs.copyFileSync.mockImplementation(() => { });
            // Mock console.log for package.json handling
            const consoleSpy = vi.spyOn(console, 'log').mockImplementation(() => { });
            handleComponentCollision(collision);
            expect(mockedFs.readFileSync).toHaveBeenCalledTimes(2);
            // Should handle 2 metafiles
            expect(mockedFs.readFileSync).toHaveBeenCalledWith('/dest/path/package.json', 'utf-8');
            expect(mockedFs.readFileSync).toHaveBeenCalledWith('/src/path/package.json', 'utf-8');
            consoleSpy.mockRestore();
        });
        it('falls back to timestamp when maxAttempts is exhausted', () => {
            const collision = {
                ...mockCollision,
                collisions: ['component.js'],
            };
            // Mock Date.now to return a consistent timestamp
            const mockTimestamp = 1234567890;
            vi.spyOn(Date, 'now').mockReturnValue(mockTimestamp);
            // Mock fileExists to return true 10 times (exhausting maxAttempts)
            // The function starts with differentiator = 1, then increments to 2, 3, etc.
            // It will try 10 times (differentiators 2-11), and if all return true,
            // maxAttempts will be 0 and it will fall back to timestamp
            mockedFileExists.mockReturnValue(true);
            mockedFs.copyFileSync.mockImplementation(() => { });
            handleComponentCollision(collision);
            // Should use timestamp as differentiator
            expect(mockedFs.copyFileSync).toHaveBeenCalledWith('/src/path/component.js', `/dest/path/component-${mockTimestamp}.js`);
            vi.restoreAllMocks();
        });
        it('falls back to timestamp when fileExists throws an error', () => {
            const collision = {
                ...mockCollision,
                collisions: ['component.js'],
            };
            // Mock Date.now to return a consistent timestamp
            const mockTimestamp = 9876543210;
            vi.spyOn(Date, 'now').mockReturnValue(mockTimestamp);
            // Mock fileExists to throw an error
            const mockError = new Error('File system error');
            mockedFileExists.mockImplementation(() => {
                throw mockError;
            });
            mockedFs.copyFileSync.mockImplementation(() => { });
            const mockUiLogger = vi.mocked(uiLogger);
            handleComponentCollision(collision);
            // Should log debug message about the error
            expect(mockUiLogger.debug).toHaveBeenCalledWith('Failed to check files for filename differentiator. Falling back to timestamp.');
            // Should use timestamp as differentiator
            expect(mockedFs.copyFileSync).toHaveBeenCalledWith('/src/path/component.js', `/dest/path/component-${mockTimestamp}.js`);
            vi.restoreAllMocks();
        });
    });
    describe('updateHsMetaFilesWithAutoGeneratedFields()', () => {
        beforeEach(() => {
            vi.resetAllMocks();
            mockCoerceToValidUid.mockImplementation((input) => input);
        });
        afterEach(() => {
            vi.restoreAllMocks();
        });
        it('updates component metadata files with project-specific UIDs', () => {
            const projectName = 'my-project';
            const hsMetaFilePaths = [
                '/path/to/component1.meta.json',
                '/path/to/component2.meta.json',
            ];
            const component1 = {
                type: 'card',
                uid: 'old-uid-1',
                config: {
                    name: 'Old Name',
                },
            };
            const component2 = {
                type: 'function',
                uid: 'old-uid-2',
            };
            mockedFs.readFileSync
                .mockReturnValueOnce(JSON.stringify(component1))
                .mockReturnValueOnce(JSON.stringify(component2));
            mockedFs.writeFileSync.mockImplementation(() => { });
            mockCoerceToValidUid
                .mockReturnValueOnce('card-my-project')
                .mockReturnValueOnce('function-my-project');
            updateHsMetaFilesWithAutoGeneratedFields(projectName, hsMetaFilePaths);
            expect(mockCoerceToValidUid).toHaveBeenCalledWith('my-project_card');
            expect(mockCoerceToValidUid).toHaveBeenCalledWith('my-project_function');
            expect(mockCoerceToValidUid).toHaveBeenCalledWith('my-project_card');
            expect(mockCoerceToValidUid).toHaveBeenCalledWith('my-project_function');
            expect(mockedFs.writeFileSync).toHaveBeenCalledWith('/path/to/component1.meta.json', JSON.stringify({
                type: 'card',
                uid: 'card_my_project',
                config: {
                    name: 'Old Name',
                },
            }, null, 2));
            expect(mockedFs.writeFileSync).toHaveBeenCalledWith('/path/to/component2.meta.json', JSON.stringify({
                type: 'function',
                uid: 'function_my_project',
            }, null, 2));
        });
        it('handles app components by updating both uid and config.name', () => {
            const projectName = 'test-app';
            const hsMetaFilePaths = ['/path/to/app.meta.json'];
            const appComponent = {
                type: 'app',
                uid: 'old-app-uid',
                config: {
                    name: 'Old App Name',
                    other: 'property',
                },
            };
            mockedFs.readFileSync.mockReturnValue(JSON.stringify(appComponent));
            mockedFs.writeFileSync.mockImplementation(() => { });
            mockCoerceToValidUid.mockReturnValue('app-test-app');
            updateHsMetaFilesWithAutoGeneratedFields(projectName, hsMetaFilePaths);
            expect(mockCoerceToValidUid).toHaveBeenCalledWith('test-app_app');
            expect(mockedFs.writeFileSync).toHaveBeenCalledWith('/path/to/app.meta.json', JSON.stringify({
                type: 'app',
                uid: 'app_test_app',
                config: {
                    name: 'test-app-Application',
                    other: 'property',
                },
            }, null, 2));
        });
        it('handles UID collisions by using differentiators', () => {
            const projectName = 'collision-project';
            const hsMetaFilePaths = ['/path/to/component1.meta.json'];
            const existingUids = ['card_collision_project'];
            const component1 = { type: 'card', uid: 'old-uid-1' };
            mockedFs.readFileSync.mockReturnValue(JSON.stringify(component1));
            mockedFs.writeFileSync.mockImplementation(() => { });
            // First call for getBaseUid() check, second call when adding differentiator
            mockCoerceToValidUid
                .mockReturnValueOnce('card-collision-project')
                .mockReturnValueOnce('card-collision-project');
            updateHsMetaFilesWithAutoGeneratedFields(projectName, hsMetaFilePaths, existingUids);
            expect(mockCoerceToValidUid).toHaveBeenCalledWith('collision-project_card');
            // getBaseUid() is called twice - once for initial check, once when adding differentiator
            expect(mockCoerceToValidUid).toHaveBeenCalledTimes(2);
            // The differentiator is appended with a hyphen, so the final UID has a hyphen before the number
            expect(mockedFs.writeFileSync).toHaveBeenCalledWith('/path/to/component1.meta.json', JSON.stringify({
                type: 'card',
                uid: 'card_collision_project_2',
            }, null, 2));
        });
        it('falls back to original uid when coerceToValidUid returns null', () => {
            const projectName = 'fallback-project';
            const hsMetaFilePaths = ['/path/to/component.meta.json'];
            const component = {
                type: 'card',
                uid: 'original-uid',
            };
            mockedFs.readFileSync.mockReturnValue(JSON.stringify(component));
            mockedFs.writeFileSync.mockImplementation(() => { });
            mockCoerceToValidUid.mockReturnValue(undefined);
            updateHsMetaFilesWithAutoGeneratedFields(projectName, hsMetaFilePaths);
            expect(mockedFs.writeFileSync).toHaveBeenCalledWith('/path/to/component.meta.json', JSON.stringify({
                type: 'card',
                uid: 'original-uid',
            }, null, 2));
        });
        it('handles empty hsMetaFilePaths array', () => {
            const projectName = 'empty-project';
            const hsMetaFilePaths = [];
            updateHsMetaFilesWithAutoGeneratedFields(projectName, hsMetaFilePaths);
            expect(mockedFs.readFileSync).not.toHaveBeenCalled();
            expect(mockedFs.writeFileSync).not.toHaveBeenCalled();
        });
        it('handles components without config property for app type', () => {
            const projectName = 'no-config-project';
            const hsMetaFilePaths = ['/path/to/app.meta.json'];
            const appComponent = {
                type: 'app',
                uid: 'app-uid',
                // No config property
            };
            mockedFs.readFileSync.mockReturnValue(JSON.stringify(appComponent));
            mockedFs.writeFileSync.mockImplementation(() => { });
            mockCoerceToValidUid.mockReturnValue('app-no-config-project');
            updateHsMetaFilesWithAutoGeneratedFields(projectName, hsMetaFilePaths);
            expect(mockCoerceToValidUid).toHaveBeenCalledWith('no-config-project_app');
            expect(mockedFs.writeFileSync).toHaveBeenCalledWith('/path/to/app.meta.json', JSON.stringify({
                type: 'app',
                uid: 'app_no_config_project',
            }, null, 2));
        });
        it('replaces hyphens with underscores in coerced UIDs', () => {
            const projectName = 'my-project';
            const hsMetaFilePaths = ['/path/to/component.meta.json'];
            const component = {
                type: 'card',
                uid: 'old-uid',
            };
            mockedFs.readFileSync.mockReturnValue(JSON.stringify(component));
            mockedFs.writeFileSync.mockImplementation(() => { });
            // coerceToValidUid returns a value with hyphens that should be converted to underscores
            mockCoerceToValidUid.mockReturnValue('my-project-card-with-hyphens');
            updateHsMetaFilesWithAutoGeneratedFields(projectName, hsMetaFilePaths);
            expect(mockCoerceToValidUid).toHaveBeenCalledWith('my-project_card');
            expect(mockedFs.writeFileSync).toHaveBeenCalledWith('/path/to/component.meta.json', JSON.stringify({
                type: 'card',
                uid: 'my_project_card_with_hyphens',
            }, null, 2));
        });
        it('handles UIDs with multiple hyphens correctly', () => {
            const projectName = 'test-project';
            const hsMetaFilePaths = ['/path/to/component.meta.json'];
            const component = {
                type: 'custom-object',
                uid: 'old-uid',
            };
            mockedFs.readFileSync.mockReturnValue(JSON.stringify(component));
            mockedFs.writeFileSync.mockImplementation(() => { });
            mockCoerceToValidUid.mockReturnValue('test-project-custom-object-type');
            updateHsMetaFilesWithAutoGeneratedFields(projectName, hsMetaFilePaths);
            expect(mockCoerceToValidUid).toHaveBeenCalledWith('test-project_custom-object');
            expect(mockedFs.writeFileSync).toHaveBeenCalledWith('/path/to/component.meta.json', JSON.stringify({
                type: 'custom-object',
                uid: 'test_project_custom_object_type',
            }, null, 2));
        });
        it('preserves UIDs without hyphens unchanged', () => {
            const projectName = 'simpleproject';
            const hsMetaFilePaths = ['/path/to/component.meta.json'];
            const component = {
                type: 'card',
                uid: 'old-uid',
            };
            mockedFs.readFileSync.mockReturnValue(JSON.stringify(component));
            mockedFs.writeFileSync.mockImplementation(() => { });
            // coerceToValidUid returns a value without hyphens
            mockCoerceToValidUid.mockReturnValue('simpleprojectcard');
            updateHsMetaFilesWithAutoGeneratedFields(projectName, hsMetaFilePaths);
            expect(mockCoerceToValidUid).toHaveBeenCalledWith('simpleproject_card');
            expect(mockedFs.writeFileSync).toHaveBeenCalledWith('/path/to/component.meta.json', JSON.stringify({
                type: 'card',
                uid: 'simpleprojectcard',
            }, null, 2));
        });
        it('handles project names with hyphens in UID generation', () => {
            const projectName = 'my-super-project';
            const hsMetaFilePaths = ['/path/to/component.meta.json'];
            const component = {
                type: 'function',
                uid: 'old-uid',
            };
            mockedFs.readFileSync.mockReturnValue(JSON.stringify(component));
            mockedFs.writeFileSync.mockImplementation(() => { });
            mockCoerceToValidUid.mockReturnValue('my-super-project-function');
            updateHsMetaFilesWithAutoGeneratedFields(projectName, hsMetaFilePaths);
            expect(mockCoerceToValidUid).toHaveBeenCalledWith('my-super-project_function');
            expect(mockedFs.writeFileSync).toHaveBeenCalledWith('/path/to/component.meta.json', JSON.stringify({
                type: 'function',
                uid: 'my_super_project_function',
            }, null, 2));
        });
    });
});
