import { translateForLocalDev } from '@hubspot/project-parsing-lib';
import { hasLocalStateFlag } from '@hubspot/local-dev-lib/config';
import { fetchProject } from '@hubspot/local-dev-lib/api/projects';
import path from 'path';
import open from 'open';
import LocalDevState from './LocalDevState.js';
import LocalDevLogger from './LocalDevLogger.js';
import DevServerManager from './DevServerManager.js';
import { EXIT_CODES } from '../../enums/exitCodes.js';
import { getProjectConfig } from '../config.js';
import { handleProjectUpload } from '../upload.js';
import { handleProjectDeploy } from '../deploy.js';
import { pollProjectBuildAndDeploy } from '../pollProjectBuildAndDeploy.js';
import { getLocalDevUiUrl } from '../urls.js';
import { CONFIG_LOCAL_STATE_FLAGS, PROJECT_DEPLOY_STATES, } from '../../constants.js';
import { isAutoOpenBrowserEnabled } from '../../configOptions.js';
import { lib } from '../../../lang/en.js';
import { debugError } from '../../errorHandlers/index.js';
class LocalDevProcess {
    state;
    _logger;
    devServerManager;
    constructor(options) {
        this.state = new LocalDevState(options);
        this._logger = new LocalDevLogger(this.state);
        this.devServerManager = new DevServerManager({
            localDevState: this.state,
            logger: this._logger,
        });
    }
    get projectDir() {
        return this.state.projectDir;
    }
    get projectData() {
        return this.state.projectData;
    }
    get targetProjectAccountId() {
        return this.state.targetProjectAccountId;
    }
    get targetTestingAccountId() {
        return this.state.targetTestingAccountId;
    }
    get projectNodes() {
        return this.state.projectNodes;
    }
    get logger() {
        return this._logger;
    }
    async setupDevServers() {
        try {
            await this.devServerManager.setup();
            return true;
        }
        catch (e) {
            this.logger.devServerSetupError(e);
            return false;
        }
    }
    async startDevServers() {
        try {
            await this.devServerManager.start();
        }
        catch (e) {
            this.logger.devServerStartError(e);
            process.exit(EXIT_CODES.ERROR);
        }
    }
    async cleanupDevServers() {
        try {
            await this.devServerManager.cleanup();
            return true;
        }
        catch (e) {
            this.logger.devServerCleanupError(e);
            return false;
        }
    }
    async projectConfigValidForUpload() {
        const { projectConfig } = await getProjectConfig();
        if (!projectConfig) {
            return false;
        }
        Object.keys(projectConfig).forEach(key => {
            const field = key;
            if (projectConfig[field] !== this.state.projectConfig[field]) {
                return false;
            }
        });
        return true;
    }
    getIntermediateRepresentation(projectNodesAtLastDeploy) {
        return translateForLocalDev({
            projectSourceDir: path.join(this.state.projectDir, this.state.projectConfig.srcDir),
            platformVersion: this.state.projectConfig.platformVersion,
            accountId: this.state.targetProjectAccountId,
        }, {
            projectNodesAtLastUpload: projectNodesAtLastDeploy,
            profile: this.state.profile,
        });
    }
    async updateProjectNodes() {
        const intermediateRepresentation = await this.getIntermediateRepresentation(this.state.projectNodesAtLastDeploy);
        this.state.projectNodes =
            intermediateRepresentation.intermediateNodesIndexedByUid;
        this.state.projectProfileData = intermediateRepresentation.profileData;
    }
    async updateProjectNodesAfterDeploy() {
        const intermediateRepresentation = await this.getIntermediateRepresentation();
        this.state.projectNodes =
            intermediateRepresentation.intermediateNodesIndexedByUid;
        this.state.projectProfileData = intermediateRepresentation.profileData;
        this.state.projectNodesAtLastDeploy =
            intermediateRepresentation.intermediateNodesIndexedByUid;
    }
    openLocalDevUi() {
        const showWelcomeScreen = !hasLocalStateFlag(CONFIG_LOCAL_STATE_FLAGS.LOCAL_DEV_UI_WELCOME);
        open(getLocalDevUiUrl(this.state.targetTestingAccountId, showWelcomeScreen));
    }
    async updateProjectData() {
        try {
            const { data: projectData } = await fetchProject(this.state.targetProjectAccountId, this.state.projectConfig.name);
            this.state.projectData = projectData;
        }
        catch (e) {
            debugError(e);
        }
    }
    async handleFileChange(filePath, event) {
        await this.updateProjectNodes();
        try {
            this.devServerManager.fileChange({ filePath, event });
        }
        catch (e) {
            this.logger.fileChangeError(e);
        }
    }
    async handleConfigFileChange() {
        await this.updateProjectNodes();
        this.logger.uploadWarning();
    }
    async start() {
        this.logger.resetSpinnies();
        const setupSucceeded = await this.setupDevServers();
        if (!setupSucceeded) {
            process.exit(EXIT_CODES.ERROR);
        }
        this.logger.startupMessage();
        if (isAutoOpenBrowserEnabled()) {
            this.openLocalDevUi();
        }
        await this.startDevServers();
        this.state.devServersStarted = true;
        this.logger.monitorConsoleOutput();
    }
    async stop(showProgress = true) {
        if (showProgress) {
            this.logger.cleanupStart();
        }
        const cleanupSucceeded = await this.cleanupDevServers();
        if (!cleanupSucceeded) {
            if (showProgress) {
                this.logger.cleanupError();
            }
            process.exit(EXIT_CODES.ERROR);
        }
        if (showProgress) {
            this.logger.cleanupSuccess();
        }
        process.exit(EXIT_CODES.SUCCESS);
    }
    async uploadProject() {
        this.logger.uploadInitiated();
        const isUploadable = await this.projectConfigValidForUpload();
        if (!isUploadable) {
            this.logger.projectConfigMismatch();
            return {
                uploadSuccess: false,
                buildSuccess: false,
                deploySuccess: false,
            };
        }
        const { uploadError, result } = await handleProjectUpload({
            accountId: this.state.targetProjectAccountId,
            projectConfig: this.state.projectConfig,
            projectDir: this.state.projectDir,
            callbackFunc: pollProjectBuildAndDeploy,
            sendIR: true,
        });
        const deploy = result?.deployResult;
        if (uploadError) {
            this.logger.uploadError(uploadError);
            return {
                uploadSuccess: false,
                buildSuccess: false,
                deploySuccess: false,
                deployId: deploy?.deployId,
            };
        }
        await this.updateProjectData();
        if (deploy && deploy.status === PROJECT_DEPLOY_STATES.FAILURE) {
            return {
                uploadSuccess: false,
                buildSuccess: true,
                deploySuccess: false,
                deployId: deploy.deployId,
            };
        }
        else if (!deploy) {
            this.logger.uploadSuccessAutoDeployDisabled();
        }
        else {
            await this.updateProjectNodesAfterDeploy();
            this.state.clearUploadWarnings();
            this.logger.uploadSuccess();
        }
        return {
            uploadSuccess: true,
            buildSuccess: true,
            deploySuccess: Boolean(deploy),
            deployId: deploy?.deployId,
        };
    }
    async deployLatestBuild(force = false) {
        this.logger.deployInitiated();
        if (!this.state.projectData.latestBuild) {
            this.logger.deployError(lib.LocalDevProcess.noBuildToDeploy);
            return {
                success: false,
            };
        }
        let deploy;
        try {
            deploy = await handleProjectDeploy(this.state.targetProjectAccountId, this.state.projectConfig.name, this.state.projectData.latestBuild.buildId, true, force);
        }
        catch (error) {
            this.logger.deployError(error);
            return {
                success: false,
            };
        }
        const success = deploy?.status === PROJECT_DEPLOY_STATES.SUCCESS;
        if (success) {
            await this.updateProjectData();
            this.logger.deploySuccess();
            await this.updateProjectNodesAfterDeploy();
            this.state.clearUploadWarnings();
        }
        else {
            this.logger.deployError();
        }
        return {
            success,
            deployId: deploy?.deployId,
        };
    }
    addStateListener(key, listener) {
        this.state.addListener(key, listener);
    }
    sendDevServerMessage(message) {
        this.state.devServerMessage = message;
    }
    removeStateListener(key, listener) {
        this.state.removeListener(key, listener);
    }
}
export default LocalDevProcess;
