import { marketplaceDistribution, oAuth, privateDistribution, staticAuth, EMPTY_PROJECT, PROJECT_WITH_APP, FEATURES, } from '../../constants.js';
import { commands, lib } from '../../../lang/en.js';
import { listPrompt } from '../../prompts/promptUtils.js';
import { isV2Project } from '../platformVersion.js';
import path from 'path';
import { getConfigForPlatformVersion } from './legacy.js';
import { logError } from '../../errorHandlers/index.js';
import { EXIT_CODES } from '../../enums/exitCodes.js';
import { hasFeature } from '../../hasFeature.js';
import { AppEventsKey, PagesKey, } from '@hubspot/project-parsing-lib/src/lib/constants.js';
export async function createV2App(providedAuth, providedDistribution) {
    let authType;
    if (providedAuth &&
        providedDistribution === marketplaceDistribution &&
        providedAuth !== oAuth) {
        throw new Error(lib.projects.create.errors.invalidAuthDistCombo(providedAuth, providedDistribution));
    }
    const distribution = providedDistribution ||
        (await listPrompt(lib.projects.create.prompt.distribution, {
            choices: [
                {
                    name: lib.projects.create.prompt.marketPlaceDistribution,
                    value: marketplaceDistribution,
                },
                {
                    name: lib.projects.create.prompt.privateDistribution,
                    value: privateDistribution,
                },
            ],
        }));
    if (distribution === marketplaceDistribution) {
        // This is the only valid auth type for marketplace
        authType = oAuth;
    }
    else {
        authType =
            providedAuth ||
                (await listPrompt(lib.projects.create.prompt.auth, {
                    choices: [
                        { name: lib.projects.create.prompt.staticAuth, value: staticAuth },
                        { name: lib.projects.create.prompt.oauth, value: oAuth },
                    ],
                }));
    }
    return {
        distribution: distribution,
        authType: authType,
    };
}
const componentTypeToGateMap = {
    [AppEventsKey]: FEATURES.APP_EVENTS,
    [PagesKey]: FEATURES.APPS_HOME,
    'workflow-action-tool': FEATURES.AGENT_TOOLS,
};
export async function calculateComponentTemplateChoices(components, authType, distribution, accountId, projectMetadata) {
    const enabledComponents = [];
    const disabledComponents = [];
    for (const template of components) {
        const { supportedAuthTypes, supportedDistributions } = template;
        const disabledReasons = [];
        if (projectMetadata) {
            const componentMetadata = projectMetadata.components[template.type];
            if (!componentMetadata) {
                disabledReasons.push(commands.project.add.error.invalidComponentType(template.type));
            }
            else {
                const { count, maxCount } = componentMetadata;
                if (count >= maxCount) {
                    disabledReasons.push(commands.project.add.error.maxExceeded(maxCount));
                }
            }
        }
        if (Array.isArray(supportedAuthTypes) &&
            authType &&
            !supportedAuthTypes.includes(authType.toLowerCase())) {
            const supportedAuthTypesString = supportedAuthTypes.join(', ');
            disabledReasons.push(commands.project.add.error.authTypeNotAllowed(supportedAuthTypesString));
        }
        if (Array.isArray(supportedDistributions) &&
            distribution &&
            !supportedDistributions.includes(distribution.toLowerCase())) {
            const supportedDistributionsString = supportedDistributions.join(', ');
            disabledReasons.push(commands.project.add.error.distributionNotAllowed(supportedDistributionsString));
        }
        const templateGate = componentTypeToGateMap[template.cliSelector || template.type];
        if (templateGate) {
            const isUngated = await hasFeature(accountId, templateGate);
            if (!isUngated) {
                disabledReasons.unshift(commands.project.add.error.portalDoesNotHaveAccessToThisFeature());
            }
        }
        if (disabledReasons.length > 0) {
            disabledComponents.push({
                name: `${template.label} [${template.cliSelector || template.type}]`,
                value: template,
                disabled: `â€“ ${disabledReasons.join(' ')}`,
            });
        }
        else {
            enabledComponents.push({
                name: `${template.label} [${template.cliSelector || template.type}]`,
                value: template,
            });
        }
    }
    return disabledComponents.length
        ? [...enabledComponents, ...disabledComponents]
        : [...enabledComponents];
}
export async function v2ComponentFlow(platformVersion, projectBase, providedAuth, providedDistribution, accountId) {
    let repoConfig = undefined;
    let authType;
    let distribution;
    try {
        repoConfig = await getConfigForPlatformVersion(platformVersion);
    }
    catch (error) {
        logError(error);
        return process.exit(EXIT_CODES.SUCCESS);
    }
    const projectContentsChoice = projectBase ||
        (await listPrompt(commands.project.create.prompts.parentComponents, {
            choices: [
                {
                    name: commands.project.create.prompts.emptyProject,
                    value: EMPTY_PROJECT,
                },
                { name: commands.project.create.prompts.app, value: PROJECT_WITH_APP },
            ],
        }));
    if (projectContentsChoice === PROJECT_WITH_APP) {
        const { authType: selectedAuthType, distribution: selectedDistribution } = await createV2App(providedAuth, providedDistribution);
        authType = selectedAuthType;
        distribution = selectedDistribution;
    }
    const componentTemplateChoices = await calculateComponentTemplateChoices(repoConfig?.components || [], authType, distribution, accountId);
    return {
        componentTemplateChoices,
        authType,
        distribution,
        projectContents: projectContentsChoice,
        repoConfig,
    };
}
export function generateComponentPaths({ selectProjectTemplatePromptResponse, platformVersion, repoConfig, projectContents, authType, distribution, }) {
    if (!isV2Project(platformVersion)) {
        return [];
    }
    const components = selectProjectTemplatePromptResponse.componentTemplates?.map((componentTemplate) => {
        return path.join(platformVersion, componentTemplate.path);
    }) || [];
    if (projectContents && projectContents !== EMPTY_PROJECT) {
        const parentComponent = repoConfig?.parentComponents?.find(possibleParent => {
            return (possibleParent.type === projectContents &&
                possibleParent.authType === authType &&
                possibleParent.distribution === distribution);
        });
        if (parentComponent) {
            components.push(path.join(platformVersion, parentComponent.path));
        }
    }
    if (repoConfig?.defaultFiles) {
        components.push(path.join(platformVersion, repoConfig?.defaultFiles));
    }
    return components;
}
