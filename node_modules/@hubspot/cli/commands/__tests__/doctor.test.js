import { EXIT_CODES } from '../../lib/enums/exitCodes.js';
import yargs from 'yargs';
import doctorCommand from '../doctor.js';
import { trackCommandUsage } from '../../lib/usageTracking.js';
import { Doctor } from '../../lib/doctor/Doctor.js';
import { uiLogger } from '../../lib/ui/logger.js';
import fs from 'fs';
import { getCwd as __getCwd } from '@hubspot/local-dev-lib/path';
vi.mock('../../lib/usageTracking');
vi.mock('../../lib/doctor/Doctor');
vi.mock('../../lib/ui/logger.js');
vi.mock('@hubspot/local-dev-lib/path');
vi.mock('fs');
// @ts-expect-error Doesn't match the actual signature because then the linter complains about unused variables
const DoctorMock = Doctor;
const mockedFs = vi.mocked(fs);
const getCwd = __getCwd;
const optionSpy = vi
    .spyOn(yargs, 'option')
    .mockReturnValue(yargs);
const date = new Date('2022-02-22');
vi.useFakeTimers().setSystemTime(date);
describe('doctor', () => {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let processExitSpy;
    const accountId = 123456;
    beforeEach(() => {
        // @ts-expect-error Doesn't match the actual signature because then the linter complains about unused variables
        processExitSpy = vi.spyOn(process, 'exit').mockImplementation(() => { });
    });
    describe('command', () => {
        it('should have the proper command name', () => {
            expect(doctorCommand.command).toEqual('doctor');
        });
    });
    describe('describe', () => {
        it('should have a description', () => {
            expect(doctorCommand.describe).toEqual('Retrieve diagnostic information about your local HubSpot configurations.');
        });
    });
    describe('builder', () => {
        it('should apply the correct options', () => {
            doctorCommand.builder(yargs);
            expect(optionSpy).toHaveBeenCalledWith('output-dir', {
                describe: 'Directory to save a detailed diagnosis JSON file in',
                type: 'string',
            });
        });
    });
    describe('handler', () => {
        let diagnosis;
        beforeEach(() => {
            diagnosis = 'Yooooooooooooooo';
            DoctorMock.mockImplementation(() => {
                return {
                    diagnose: vi.fn().mockResolvedValue({ diagnosis }),
                    accountId,
                };
            });
        });
        it('should track the command usage', async () => {
            await doctorCommand.handler({});
            expect(trackCommandUsage).toHaveBeenCalledTimes(1);
            expect(trackCommandUsage).toHaveBeenCalledWith('doctor', undefined, accountId);
        });
        it('should log the diagnosis if it is defined', async () => {
            await doctorCommand.handler({});
            expect(uiLogger.log).toHaveBeenCalledTimes(1);
            expect(uiLogger.log).toHaveBeenCalledWith(diagnosis);
            expect(processExitSpy).toHaveBeenCalledTimes(1);
            expect(processExitSpy).toHaveBeenCalledWith(EXIT_CODES.SUCCESS);
        });
        it('should log an error if the diagnosis is undefined', async () => {
            DoctorMock.mockImplementationOnce(() => {
                return {
                    diagnose: vi.fn().mockResolvedValue(undefined),
                    accountId,
                };
            });
            await doctorCommand.handler({});
            expect(uiLogger.error).toHaveBeenCalledTimes(1);
            expect(uiLogger.error).toHaveBeenCalledWith('Error generating diagnosis');
            expect(processExitSpy).toHaveBeenCalledTimes(1);
            expect(processExitSpy).toHaveBeenCalledWith(EXIT_CODES.ERROR);
        });
        it('should write the output to a file if output-dir is defined', async () => {
            mockedFs.writeFileSync.mockImplementationOnce(() => { });
            const expectedOutputFile = `/foo/hubspot-doctor-${date.toISOString()}.json`;
            await doctorCommand.handler({
                outputDir: '/foo',
            });
            expect(uiLogger.log).not.toHaveBeenCalled();
            expect(uiLogger.error).not.toHaveBeenCalled();
            expect(mockedFs.writeFileSync).toHaveBeenCalledTimes(1);
            expect(mockedFs.writeFileSync).toHaveBeenCalledWith(expectedOutputFile, expect.stringContaining(diagnosis));
            expect(uiLogger.success).toHaveBeenCalledTimes(1);
            expect(uiLogger.success).toHaveBeenCalledWith(expect.stringMatching(/Output written to /));
            expect(processExitSpy).toHaveBeenCalledTimes(1);
            expect(processExitSpy).toHaveBeenCalledWith(EXIT_CODES.SUCCESS);
        });
        it('should handle absolute paths', async () => {
            mockedFs.writeFileSync.mockImplementationOnce(() => { });
            const cwd = '/some/path/to';
            getCwd.mockImplementationOnce(() => cwd);
            const expectedOutputFile = `${cwd}/foo/hubspot-doctor-${date.toISOString()}.json`;
            await doctorCommand.handler({
                outputDir: './foo',
            });
            expect(uiLogger.log).not.toHaveBeenCalled();
            expect(uiLogger.error).not.toHaveBeenCalled();
            expect(mockedFs.writeFileSync).toHaveBeenCalledTimes(1);
            expect(mockedFs.writeFileSync).toHaveBeenCalledWith(expectedOutputFile, expect.stringContaining(diagnosis));
            expect(uiLogger.success).toHaveBeenCalledTimes(1);
            expect(uiLogger.success).toHaveBeenCalledWith(expect.stringMatching(/Output written to /));
            expect(processExitSpy).toHaveBeenCalledTimes(1);
            expect(processExitSpy).toHaveBeenCalledWith(EXIT_CODES.SUCCESS);
        });
        it('should log an error message when writing the output fails', async () => {
            const errorMessage = 'Something bad happened';
            mockedFs.writeFileSync.mockImplementationOnce(() => {
                throw new Error(errorMessage);
            });
            await doctorCommand.handler({
                outputDir: '/foo',
            });
            expect(uiLogger.error).toHaveBeenCalledTimes(1);
            expect(uiLogger.error).toHaveBeenCalledWith(expect.stringMatching(/Unable to write output to/));
            expect(mockedFs.writeFileSync).toHaveBeenCalledTimes(1);
            expect(mockedFs.writeFileSync).toHaveBeenCalledWith(`/foo/hubspot-doctor-${date.toISOString()}.json`, expect.stringContaining(diagnosis));
            expect(processExitSpy).toHaveBeenCalledTimes(1);
            expect(processExitSpy).toHaveBeenCalledWith(EXIT_CODES.ERROR);
        });
    });
});
